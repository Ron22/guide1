
## Welcome

---

#### Overview

![MaaxFrame Logo](http://www.maaxframe.com/assets/img/Maax-logo-and-text-250x64.png)

Welcome to MaaxFrame - All In One Application. Strong relationships are at the core of every organization's success. MaaxFrame brings ease and order to the creation, development, and maintainance of your organization's important relationships.

MaaxFrame consists of interrelated records in modules such as Accounts, Contacts, Opportunities, Events, Meetings, Emails, etc. and wraps your data in an intuitive user interface which helps make sense of these different elements of your business. Whatever your organization's focus - sales, marketing, support, or other ventures - MaaxFrame flexible modules bend to align with your business' models and practices. Manage your relationships from inception to fruition and beyond with MaaxFrame built-in modules and relationships as well as your custom modules and configurations available to MaaxFrame administrators.

Thank you for using MaaxFrame, the world’s first advertisement driven and subscription based CRM service and
software solutions provider. This is our User’s Manual, which will assist you in using the hosted version of our
software.

Our interface has been designed to make navigation and data entry as simple as possible. We have color-coded our
menu items and our layout and design is simple and intuitive. Our system is a team sales and support tool,
automating many procedures and providing a means of tracking sales and support issues in a collaborative
environment.

The first step to using our software is customizing all of the settings and information for your particular business,
which includes some decisions that you must make before using the software. We have developed a Quick
Start Guide that is valuable for those of you who are already somewhat familiar with CRM software as a hosted
service. Our system is very user friendly, those of you who are Internet savvy and use many web-based applications
such as email or frequently use customer relationship management should be able to get up and going very, very
quickly.

#### Core Features

##### Sales Automation

* Target, Lead, and Contact management to direct and organize efforts throughout the sales life cycle
* Account management to aggregate interactions with organizations and individuals
* Opportunity management to pursue new business, share sales information, and track deal progress
* Sales Forecasting to enable sales representatives and managers to understand upcoming business
* Quote management to prepare potential sale figures including multiple line items, currencies, and tax codes
* Product management to capture the details of your organization's goods and services

##### Marketing Automation

* Target, Lead, and Contact management to support the creation of new relationships
* Email marketing campaigns to present relevant email messages to groups of recipients
* Campaign management and reporting for tracking campaigns across multiple channels and analyzing the effectiveness of marketing activities
* Target List management to organize groups of recipients for ensuring campaign message relevance
* Web-to-Lead Forms to capture lead information directly from external web input
 
##### Customer Support

* Management to track service and resolution of customer issues
* Bug tracking to identify, prioritize, and resolve product issues
* Contact and Account management to track support history and enable continuity of service
* MaaxFrame to provide clients with self-service capabilities support activities
* Knowledge Base to manage information and share it externally

##### Record Keeping

* Email, Task, Call, and Meeting management to facilitate day-to-day work
* Note management to affix information and file attachments to other MaaxFrame modules
* Document management to track living documents and their changes
* Contract management to capture and maintain sales and service contracts
* Search capabilities to quickly and easily locate your data 

##### Collaboration

* Shared Email and Calendar to provide visibility across individuals and teams
* Connectors and tools to leverage third-party information regarding your prospects and clients

##### Drill Down Reporting

* Report creation and management to gain insight into your organization's MaaxFrame data
* Home page dashlets to display important tables and reports





# Introduction

One of the best investments you can make in your MaaxFrame success is to have a clear plan. Just as you wouldn’t build a house without a blueprint, you don’t want to start using MaaxFrame without a plan. A plan will help you to communicate with everyone, to do things in the right order, identify key resources, and keep a clear end date in mind.

As you plan and prepare to get MaaxFrame up and running, complete the following steps:

* Build your team
* Define your company’s vision
* Define and prioritize your goals
* Develop your rollout plan
* Define key aspects of your process and diagram the process flow
* Map your process to MaaxFrame functionality
* Decide which reports you need
* Train your administrator
* Communicate with your end users

---

### Build Your Team

To a small business with limited resources, the term “project team” may sound intimidating, but it doesn’t take a huge team to implement MaaxFrame. You just need to cover the following key roles (and the same person can cover more than one role):

* An executive sponsor
* A project owner to get the application up and running
* An administrator to manage MaaxFrame day to day
* A power user who really knows your company’s business processes

The **executive sponsor** lends his or her influence to the project by becoming its champion. Having that person’s full support and participation—from the planning stage until the go-live date and beyond—is absolutely critical.

The **project owner**, who leads the implementation project, must understand the organization’s business processes to map them to MaaxFrame.

The person is designated as the **system administrator** manages MaaxFrame day to day and makes new functionality available. It’s also a good idea to have the administrator involved in the implementation. A technical background is not necessary, but may be helpful.

And to make sure that Salesforce CRM meets the needs of your end users, it is essential to involve key **power users** in the planning process.

---

### Find the Right MaaxFrame Administrator

Software as a service (SaaS) makes system administration much easier that it was with traditional software. Setting up the application, customizing and maintaining it, training users, and “turning on” the new features that become available with each release are all just a few clicks away.

The system administrator is one of the most important people when it comes to making your MaaxFrame implementation a success. The role of the administrator for a small business is not necessarily a full-time position. In the initial stages of the implementation, the role will require more concentrated time (about 50%). After go-live, managing MaaxFrame day to day will require much less time (10–25%).

Find the right person for the job and continue to invest in that person’s professional development. Here are some qualities to look for in an administrator:

* A solid understanding of your business processes
* Knowledge of the organizational structure and culture to help build relationships with key groups
* Excellent communication, motivational, and presentation skills
* The desire to be the voice of the user in communicating with management
* Analytical skills to respond to requested changes and identify customizations.

You may also want to take advantage of Premier Success & Administration to assist with key tactical responsibilities. Through this service, our experts can help your team with administrative tasks and serve as an extension of MaaxFrame internal team.

---

### Identify Your Key Players

It’s time to pick your team.

---

### Define Your Vision

Every successful project starts with a clear vision of where you want to be as a result of the project. Your vision will define a clear purpose for the initiative, drive ongoing commitment, and provide a way to measure and prove results.

It’s very important that your key executives are involved in defining this vision, that you document the vision, and that it is understood by everyone.

> Action: This vision should be a key component of future communication with your users.

---

### Define and Prioritize Your Goals

In addition to a clear destination, it also helps to have a plan that breaks down the journey into manageable steps. Setting your goals involves two key steps:

* Define the goals that support this vision
* Prioritize and document your requirements

#### Define Your Goals

Determine which concrete goals support your vision. Keep in mind that different groups within your organization are likely to have different goals. For example:

* Executives want to improve sales and track top performers or customer issues.
* Sales managers want better visibility into their pipelines and reports that summarize key information.
* Sales reps want to easily access the sales materials they need and cut down on administrative work.

MaaxFrame provides various reports to help measure whether you’ve reached your goals.

#### Prioritize Your Goals

Most people, and most organizations, want to take on more than they can handle at any one time. Clearly defining your goals and then prioritizing them will make it easier to decide what to put off, should that become necessary. Having some early “wins” is essential. When people experience the value of MaaxFrame first hand, they’re more likely to support adding additional features.

---

### Develop Your Rollout Plan

Customers typically take the approach of walking before they run. They focus first on a subset of the functionality available in MaaxFrame—allowing users to get comfortable with the application and adopt the most critical features—and then add more functionality during later phases.

It’s important to build your plan around the key areas you want to introduce first, then build your roadmap on the additional areas you will expand later.

Here’s an example of how one customer decided to approach their deployment, broken into three phases:

***Phase 1***: Import accounts and existing pipeline for general account and opportunity management
Introduce a Chatter group for MaaxFrame training and project communication

***Phase 2***: Upload existing leads and begin tracking leads from various sources
Introduce campaign management to track marketing initiatives

***Phase 3***: Begin tracking customer issues by onboarding the customer service team and using cases
Launch forecasting to the sales team

---

### Define Key Aspects of Your Process and Diagram the Process Flow

When defining your process, it helps to follow these steps:

* Make sure you understand key MaaxFrame terminology
* Identify key characteristics of your business processes
* Define and develop a visual overview of your own process
* Clarify what happens at each step—what inputs are needed, who does what, and how to measure the results
* Map your business processes to MaaxFrame

---

### Understand Key Salesforce CRM Terminology

* ***Leads*** – A lead is any person that may be interested in your products or services; for example, someone you met at a conference or who filled out a form on your website is a lead. If a rep qualifies a lead and decides to pursue it, the lead is “converted,” which automatically transforms it into three objects: an account, a contact, and an opportunity.

* ***Accounts*** - An account is an organization, individual, or company that you want to track in MaaxFrame. An account can include customers, competitors, partners, or any other entities that make sense for your business. An account record contains—or connects to—all information about your interactions with the company, such as in-progress and completed opportunities, your points of contact, and records of past interactions.

* ***Contacts*** - The contact object stores information about people who work at the companies represented by the account object. A contact record contains all relevant information about the person, such as phone numbers, titles, and role in a deal, and much more. With contacts, you can capture all the personal information you need to develop the relationships that are so important in sales.
When a sales rep converts a lead in MaaxFrame, the information in the lead is automatically transferred to the contact. As your engagement with the company widens and your reps meet more people, they can keep creating additional contacts associated with the corresponding account.

* ***Opportunities*** – The opportunity object contains the information for every deal you’re tracking, such as deal size and expected close date. The opportunity object is at the core of your sales process. By adding an opportunity, you build a “pipeline” you can use for forecasting.

* ***Activities*** – Activities consist of the tasks, events, calls, and emails that make it possible to track every customer interaction.

---

### Outline the Key Aspects of Your Sales Process

For most businesses, outlining their basic sales process includes gathering the following information:

* Generating leads – Where do leads come from? How do they get into MaaxFrame? What happens next? What information do you want to measure about leads?
* Optimizing lead flow – How do you manage open leads? How do you check for duplicates? How do you work through leads? How do you measure conversion and top performers?
* Closing deals – How do you manage the sales funnel? How can you measure top deals, closed business by month, and month-to-date trending?

---

### Create Your Process Overview

The goal of this step is to come up with a visual overview of your processes. Here’s an example of a sales process:


[! Sales Process]img/sales_process.jpg)

Discuss the sample process with your project team and modify it to fit your organization. If you don’t have a defined sales process, a CRM implementation is a good time to set one up.

To set up your own sales process:
* Start at the point where a lead is qualified as an opportunity.
* On a whiteboard, draw each step as you ideally want the information to flow.

---

### Map Your Process to MaaxFrame Functionality

The next step is to map your ideal process to MaaxFrame and establish the names you give to your data elements and the fields in MaaxFrame. For example, you may call a customer “Company,” while the corresponding field in MaaxFrame is “Account.”

To start the mapping process, review the fields associated with the Opportunity process—which includes the fields for Leads, Accounts, Contacts, and Opportunities—and answer the following questions:
* Do you need all the fields? Review the fields and decide which can be removed.
* Do you need to rename standard fields so they make more sense; for example, change “Account” to “Company”?
* Do you need custom fields that are unique to your business?

---

### Decide Which Drill Down Reports You Need

Decide which reports you need to generate based on the goals you defined earlier. MaaxFrame provides dozens of standard reports with drill down feature. Here are a few of the most commonly used reports:

* ***Account Revenue by Industry***: Shows revenue accounts categorized by industry
* ***Account Owner***: Who owns which account
* ***Lead by Status and Industry***: Created leads in last six months categorized by lead status
* ***Leads with last activity > 30 days***: Which leads need attention
* ***Sales Forecas***: Estimate of your sales for the forecast period
* ***Opportunity by Source***: How effective are all opportunity sources
* ***Campaigns***: Active
* ***Contact Distribution***: Global Distribution of contacts
* ***Sales trend for current year***: Total and average revenue per year

For a list of additional reports, navigate to the Reports tab in MaaxFrame; on the left side, you will see a list of report folders organized by function (CRM Reports, Adhoc Reports, etc.). Click into the folder to view these standard reports. You can modify these reports or create your own from scratch. Thinking about what information you want to capture is a critical step before you begin customizing the application. Remember: The system is only as good as the information you can pull into a report.

---

### Train Your Administrator

Investing in your administrator is the best way to ensure success. MaaxFrame offers both virtual self-paced training with full support. The self-paced support are available with your licenses around the clock at no additional charge included in [Dedicated Edition](http://www.maaxframe.com/pricingbox.html). During the implementation, you may want to consider getting help from our certified managers. They can assist with all aspects of the implementation, and many customers find it useful to leverage managers’ expertise and technical skills.

---

### Communicate with Your End Users

With clear goals set, you can now engage your users. User adoption is critical for MaaxFrame success.

You want the introduction of MaaxFrame to come as a surprise to users. As it, start building enthusiasm and keep your users updated as your go-live date approaches. For the highest impact, these communications should come from the executive sponsor. Here are some approaches that have worked for other customers:

* Build anticipation by enlisting the help of your marketing staff in treating the MaaxFrame implementation like a product launch.
* Focus on two or three aspects of MaaxFrame that will make your users’ lives easier.
* Reach out to users who seem particularly enthusiastic and give them a role in helping other users once you’re “live.”
* Sponsor contests and offer incentives to help build excitement.

One of the best ways to get people on board is to get them involved. Give them a voice and be sure to make changes based on their feedback. Then, communicate the difference their input made on the project’s launch.

>Recommendation: Create a group to share information about your MaaxFrame deployment. You can consolidate all materials, training resources, and conversation into one central location. You can also share key milestones and achievements related to your MaaxFrame deployment. Make sure that your executive sponsor is engaged and posting updates and feedback to your users.

---

### Summary and Checklist: Prepare

Careful preparation and planning will help make the remaining steps in implementing MaaxFrame go smoothly.





# Setup MaaxFrame

This section tells you how to take the next steps by outlining the key areas to begin setting up MaaxFrame, including:

* Company profile
* User access and permissions
* Customization
* Adding users
* Importing data

---

## Set Up Your Company Profile

The company profile information determines basic settings related to time zones, language, and how the fiscal year is defined. You can leave the default settings as is; however, it’s important to know where to find and change this information.

* Company profile – These settings use your local time for setting the time zone, default language, and the default currency.
* Fiscal years – The fiscal year definitions are used in reporting, opportunities, and forecasting. The default fiscal year setting is a 12-month calendar year, with the first day of the fiscal year starting on any first day of the month. However, you can choose custom fiscal year periods.

![company]img/company.PNG)

---


## Establish User Access and Permissions

There are some key components that determine users’ access to data as well as what they can do with the data they have access to.

### Data Access

When setting up MaaxFrame for the first time, you need to make some decisions about who will have access to what data. In MaaxFrame, there are four ways to control data access:
  
* ***Organization-wide defaults*** – Configure the baseline access users will have to your data.
* ***Role hierarchy*** – Determine the level of visibility users have to data.
* ***Sharing rules*** – Extend access to data if you’ve restricted access through your organization-wide defaults.
* ***Manual sharing*** – Provide the flexibility to allow record owners to manually give access to other users.

#### Organization-Wide Defaults

These settings, which determine the default level of data access for different types of information, are referred to as “organization wide defaults.” These include:

* ***Private*** – Users can access (view and edit) their information and that of those below them in the role hierarchy.
* ***Public Read Only*** – Users can view all data, but can edit only their information as well as that of those below them in the role hierarchy
* ***Public Read Write*** – Users can view and edit all data

For smaller organizations, we recommend granting at least Public Read Only access to create a collaborative working environment.

Examples:

* To allow all users to see everyone’s accounts, but not everyone’s opportunities, set access for account records to Public Read Only and for opportunity records to Private.
* To allow the operations team to calculate commissions, they need to see opportunities. However, you don’t want them to edit the opportunities. To allow read-only access, set opportunity records to Public Read Only.
* To set up organization-wide-defaults, please refer to our techincal guide.

For an overview of user access and permissions, view our Techincal Guide : Setup.

#### Role Hierarchy

The role hierarchy looks similar to an organization chart, but it has a different purpose. Because the role hierarchy is based on who needs to work with what data to do his or her job, role hierarchies usually have fewer layers and the people at the top are not necessarily those at the top of the org chart.

![Access]img/access.PNG)

The person in the top role (i.e Admin) has full access (view ,edit and delete ) to his or her data as well as the data of anyone lower in the hierarchy. Two common ways to set up role hierarchy are by region or by product.

There are three basic steps to setting up a successful role hierarchy:

1. Define the basic roles, such as sales representative, director of sales, and CEO. It’s not necessary to create individual roles for each title; the idea is to simply define a hierarchy that gives users in higher-level roles access to the information entered by users in the lower-level roles.
2. Build the role hierarchy based on how information should roll up for reporting and on who should see what data.
3. Assign individual users to the roles.

### Sharing Rules

Sharing rules let you make automated exceptions to your organization-wide defaults for particular sets of users, so you can give them access to records they don’t own or can’t normally see. Sharing rules, like role hierarchies, are only used to give additional users access to records—they cannot be stricter than your organization-wide default settings.

![Sharing Rules]img/sharing_rules.PNG)

### Manual Sharing

Sometimes it’s impossible to define a consistent group of users who need access to a particular set of records. In those situations, record owners can use manual sharing to give read and edit permissions to users who would not normally have access to the record. Although manual sharing isn’t automated like sharing rules, it gives record owners the flexibility to share particular records with users that need to see them.

#### Permissions

Profiles control what users have permission to do with the data they have access to, and how they view the information.Please refer to our technical guide.

#### Understand Profiles

A profile is a collection of settings and permissions that defines how users with particular profile access records, how they see their data, and what they can do within the application. For MaaxFrame Premium Editions, you can use the standard MaaxFrame profiles but you can’t create custom profiles. Even so, it’s important to understand profiles and how they work together with the organization-wide defaults and the role hierarchy. The most important profiles include:

* System Administrator – Can configure and customize the application
* Standard User – Can run reports and create and edit records


When you add users as you prepare to go live, you will assign one of these profiles to each user.

---

## Customization

When you sign on with MaaxFrame, it’s ready to use as is. But you can also easily modify MaaxFrame so that it’s an even better fit for your business and your users. In fact, the more you customize the application to fit your specific users, the more comfortable they’re likely to be—and customization can do great things to boost your adoption rates.


In this section, you’ll learn about customization and get links to step-by-step procedures for making MaaxFrame your own.

* Customization tips & tricks
* What can you customize
* Whether to use the lead functionality
* Capturing leads from your website

### Use Customization Tips & Tricks

Customizing MaaxFrame is so easy that there’s a tendency to create lots of fields that end up not being used. For that reason, it’s important to take a step back before you dive in.

Here are the top five things to think about before starting to customize:

* ***Think before you build*** – Start with the end in mind by identifying your end goal. Think about what information you want to pull out of the system, and then make sure you have the fields to match. At the end of the day, MaaxFrame is only as good as what’s in your reports.

* ***Ask for input*** – Talk to your users to find out what’s critical for them to know. Then capture that information to run your business.

* ***Seed and grow*** – Start with the basic fields you need and then identify new fields that could make your business run even better. This approach ensures you don’t turn off your users.

* ***Run reports*** – Run reports about one month after you go live to find out which fields are not being used. Use the opportunity to survey users about what could be improved.

* ***Make changes on the fly*** – In response to feedback, make changes immediately to gain instant credibility. Make sure you communicate any changes, because users don’t like it when anything that affects their work happens “magically.”

### Know What Can You Customize

You can customize many different MaaxFrame components; however, most customers customize three things:

* Fields
* Page layouts
* Reports

#### Customize Fields

Because fields hold the data you want to capture and report on, it’s important to make sure you have fields for important data elements and that those fields have names that make sense to your users. Here are common approaches to customizing fields:

![fields]img/field.PNG)

* Modify the standard MaaxFrame fields – MaaxFrame provides commonly used fields for standard records such as accounts, contacts, opportunities, and leads.
  * For example, the Lead object has a standard field called “Lead Status,” which has existing values of “Attempted to Contact,” “Cold,” “Hot,” "Pre-Qualified," "Warm," and few more. You can easily add a new value called “Dukewarm.”
* Create fields from scratch – If a standard MaaxFrame field that you need doesn’t already exist, you can easily create a custom field. For example, you can add a new picklist to capture “Lead Type” and track the main competitor in the sales cycle.
* Do both! Combine standard fields and custom fields to create the best experience for your users.

#### Customize Page Layouts

Page layouts define how fields—standard and custom—look to your users and which fields are required; that is, they can’t be saved unless the user enters a value. You’ll want to customize your layouts so that they’re attractive and easy to use. It may be tempting to create many required fields to force users to enter data; however, keep in mind that user satisfaction tends to suffer when there are too many required fields.

![Layout]img/layout.PNG)

Here’s what you can do to customize page layouts:

* Remove unnecessary fields
* Change field locations
* Create new sections
* Determine if filling in a field is required before saving

#### Customize Reports

* Being able to easily generate reports containing the information that’s most important to you is one of the great things about MaaxFrame. With a large number of standard reports available out of the box, you can be reporting in no time.

* In the planning process, you determined what information you would need to pull from MaaxFrame based on your current business needs. Then you customized the application based on those needs.

* After you add the custom fields to MaaxFrame, it’s time to re-evaluate if you have all the information you need to pull the proper reports.

![reports]img/reports.PNG)

Now you’re ready to start creating your reports. Here’s what you can do with reports:

* Customize the standard reports to better fit your business needs.
* Create custom reports from scratch and determine which fields they contain, how they’re laid out, sorting options, date ranges, and charting options.
* Leverage pre-built dashboards that contain all the underlying reports tied to the dashboard.

### To Lead or Not to Lead?

An important step in setting up MaaxFrame is to decide whether or not to use lead functionality. Leads are a critical part of the sales cycle of most businesses, and MaaxFrame includes a lot of very useful lead functionality, such as analyzing how leads convert or finding your best channels. Some companies decide not to use lead functionality because it requires an additional step to turn a prospect into an opportunity. What's right for you depends on your business processes.

![Leads]img/leads.PNG)

#### Take Advantage of Lead Functionality

Leads are unique among MaaxFrame records because they come with special functionality, including:

* ***Lead Conversion*** – A benefit of using leads in MaaxFrame is that it creates a separate area in which you can keep information in any kind of format to track anyone who ever expressed interest. This approach keeps a clean distinction between leads and contacts, so you don't have to worry about “dirty” data or duplicates. If you don't use leads, you can't run an analysis of how leads convert or the best channels for creating leads.
* ***Reports*** – Available reports show conversion rates, the time required to convert a lead, and lead channels that are the best performers when it comes to bringing in deals.
* ***Web-to-Lead*** – Getting leads from multiple channels is critical to any business. By using the Web-to-Lead functionality, you can easily create forms that capture leads from your website.

To learn more about leads, take a look at our tip sheet within the Help & Training portal refer to our techical guide.

### Capture Leads from Your Website

If you have decided to use leads, it makes sense to also evaluate the Web-to-Lead functionality. You probably have a website that lets prospects contact you te your product or service.

![Leads Website]img/lead_website.PNG)

To make the most of your website:

* Customize MaaxFrame to use Web-to-Lead functionality to capture leads when prospects fill in a form.
* Bring that information right into MaaxFrame.

Setting up this functionality is as simple as deciding which fields to include on the Web-to-Lead form, creating a URL as a landing page (such as a “thank you” page), and clicking a button to generate the HTML code. Your webmaster will jump for joy when you deliver HTML code that's ready to deploy immediately.

## Add Users

When MaaxFrame is set up the way you want it, you're ready to add users.

Adding users is a fairly easy task. Earlier we covered profiles and setting up your organization's role hierarchy. When you add users, you associate actual users with those profiles within your role hierarchy, so users can log in and access the data that's appropriate for them.

![Add Users]img/add_users.PNG)

Adding users serves three important purposes:

* Once you add users, you can import data and automatically associate that data with the correct users.
* By associating roles and profiles with all users, you can determine how they see data, what they can do in the application, and how their data rolls up.
* When you add a user, MaaxFrame uses that user's record to generate an invitation to log into the application.

> Tip: If you want to notify users to reset password, be sure to “Reset New password” button when you go through the process of adding users. And then You can edit the user records and generate usernames and passwords whenever you're ready for users to actually log in.

## Import Data

The final task before you're ready to go live is to import your data into MaaxFrame. To help you, MaaxFrame has wizards to walk you through the process and provide some tips along the way. When the import is complete, you're can start to train your users and announce that MaaxFrame is ready for business.

> Note: This import step is probably the most complex task in any other platforms bur not in MaaxFrame , it's ease to use.

Most companies already have account and contact information stored somewhere—usually in Act!, Goldmine, or Microsoft Outlook, as well as in spreadsheets, on sticky notes, or in the heads of their sales reps. Getting that information out of Outlook and off the sticky notes and into your organization's knowledge base is one of the most important steps in the implementation process.

![Import]img/import.PNG)

Although you could collect all these resources and enter them one by one, it's obviously not efficient to enter hundreds or even thousands of records by hand. MaaxFrame provides a step-by-step data import wizard that walks you through the process of importing leads, accounts, and contacts.
 
### Prepare to Import Your Data

Best practices for importing your data include having a well thought-out plan, properly preparing the data, and doing a test run.
Planning your data import includes the following steps:

* Identifying your data sources data sources: Is your data in spreadsheets?
* Listing fields in your current data records.
* Mapping your current fields to the MaaxFrame fields.

### Prepare Your Data

We suggest you “scrub” your data before importing it into MaaxFrame because starting with clean data really pays off. Remember: “Garbage in, garbage out.”

Here are some tips for preparing your data:

* The MaaxFrame import wizard was designed to work with Microsoft Excel. If necessary, export your data from any other data sources to Excel first.
* Now is a good time to standardize naming and clean up your data. For example, set standards for company names (such as International Business Machines instead of IBM) or the way countries are listed (USA instead of United States).
* Take time to weed out “dirty” data and de-duplicate people who may be in the system multiple times.
* Review your Excel file to see if you missed any critical data elements for which you haven't yet created custom fields. For example, if your sales reps are tracking the number of employees at each account, you'll need a field to store that information in MaaxFrame.
* Map your data columns to the  MaaxFrame field names. For example, the Company field in Microsoft typically maps to the Account field in MaaxFrame. Consider renaming the column headers in your Excel file so they match the field names in MaaxFrame exactly. This step will simplify the mapping step in the wizard.
* Wherever possible, assign the correct owners to records. If you don't have all the records assigned, the default owner is the administrator who performs the import.
* Now start importing your data.

![Import 1]img/import1.PNG)

Test the import: Test a small sample—approximately 5 to 10 records—before going ahead with the full import. When you analyze the results of your test, try this approach:

* Build a custom report or custom view that lets you see at a glance whether the data is laid out correctly.
* Open a record and compare it against the import file. Confirm that the record's fields show what you want them to show.
* Validate the test results with selected stakeholders or power users.
* Make changes to the import file or make changes to MaaxFrame based on the test results. For example, data could import incorrectly because it was mapped to the wrong field.
* Delete the test records and test again after making your changes. Repeat this process until you're sure the data was imported accurately and that it is displayed correctly in the reports and views your users will see.

### Import Your Final Data

Once your test results meet your expectations, you're ready to import your file or files. Here are a few suggestions for importing data:
* Consider importing data during non-working hours – If the system is live for some groups before others, this approach helps avoid confusion.
* Give yourself some cushion for error – Don't try to import your data the day before sales training, for example.
* Validate your data – Run key reports and display important screens to make sure all the data was imported into the fields where it belongs and in the format you want.

# Home

MaaxFrame Home page houses the dashboard and activity stream which allows users to view pertinent record information via various dashlets and activity stream posts. Every user in MaaxFrame can configure their dashlets based on the display options and filters available from their dashboard. User's can also personalize their activity stream to only view posts specific to records that are important to them. This documentation will go over the basics of the Home page as well as the various options available to customize the Home page to best fit your individual needs.

This is your new sales automation home page, where you can manage your customer relationships and interact with
your MaaxFrame.You will see your Dashboard and a quick list of upcoming events for the week. You can also see your task list and any email if any are active.

There are quick view on the screen to the dashboard, which is a standard view, pie chart view and
tasks for the team members. Also, you may schedule events, create a task, or create a email.

On the top bar there are menus under Home, which are links to important functionality tabs for your MaaxFrame .
Some of these features can only be make visible to the administrator account of your organization.

Top Menu Home Involves:

* Dashboard: this is default the page which opens when a user logged in.
* Email: this show functionality for sending emails through MaaxFrame.
* My Events: this will show future events which are created or which will be going to held.
* My Tasks: this will show the tasks which are done and creatin the new tasks.

## Dashboard

It will be the default view which will be shown to the user as logged in, this will show the widgets such as Lead by source, Lead by industry, Opportunities pipeline, Leads Distribution and many more.

![Dashboard]img/Dashboard.png)
<center> Fig. ***3.01 Home -> Dashboard*** </center>
<br>

View of dashboard can be changed by using the widgets sequence and widgets by default can be changed under settings, detailed information can bee seen in MaaxFrame techincal guide.


## Email

---

#### Overview

MaaxFrame's Emails module allows users to receive and send email through the application using their personal email address or a group inbox. Users have the ability to view email through MaaxFrame and also the ability to store email in MaaxFrame. Email stored in MaaxFrame may then relate to other MaaxFrame records such as contacts, cases, accounts, and many others. This documentation will cover how to use the MaaxFrame module as well as the various actions and options available from within the module.


#### Email Module Tab

The Emails module tab is typically located under the Home tab on the navigation bar at the top of MaaxFrame screen. Click the tab to access the Emails list view. You may also hover on the top tab to display the menu, which allows you to perform important actions within the module.

The Actions menu allows you to perform the following operations:

Menu Item | Description
---|---
Send An Email | Opens the list view layout to search and display my send emails
Create Drafts | Opens the list view layout to the list of draft created.
Attachments | Inculde attachments from the system of the user.

***NOTE:  MaaxFrame allows you to use your eMail client of choice and syncs to your server in the background.  It also interfaces with your client on your mobile and/or PC to pass messages to the email client.  While sitting in the background maax links all your emails to CRM clients / leads and auto creates tickets and replies to all your support emails.***

![Email Description]img/email3.png)

#### Email Quick View

- Email Fields

   - The Emails module contains a number of stock fields which come out-of-the-box with MaaxFrame. The below definitions are suggested meanings for the fields, but the fields can be leveraged differently to best meet your organization's needs.

- Composing Emails

   - One of the most common methods of composing email is via the Compose button in the Emails module. This opens up the compose layout which allows you to enter in all the relevant information for the email.

   ![Email Creation]img/email1.png)

- Adding Recipients

  - When composing an email, you can select email recipients from the address book, which lists existing users, contacts, leads, targets, and accounts. By default, all of these individuals are listed in the address book; however, you can filter the list if you want to view a specific group such as contacts or users. You can also search for an individual by first name, last name, email address, or account name.

- Adding Attachments

  - MaaxFrame allows you to send attachments along with your email. Attachments can be files from your local computer or documents from within MaaxFrame.Alterative way to Add attachments is to go through the "Email Addresses" list viewand can easily attach the files.

  ![Email Creation1]img/email2.png)

- Saving Drafts

  - As an alternative to sending an email right away is to saving it as a draft. You can save an email as a draft so you can continue composing it at a later time. To save an email as a draft while composing, simply click "Save As Draft". 
  Any emails saved as drafts can be retrieved from the folder pane under "Corporate Views" > "Drafts". Any recipients added, and signatures used on the email are all saved in the draft.

- Sending

  - To send an email to the recipients added on the To, Cc, and Bcc fields, simply click "Send".


 
## My Events

---

#### Overview

MaaxFrame Events allows users to easily schedule, view, and manage their activities (e.g. calls, meetings, calendar) in one place. The calendar will show your calls, meetings, are an invitee on the call or meeting. You can also view other user's scheduled activities via the calendar option. This documentation will cover how to use the Calendar module as well as the various actions and options available from within the module.

#### My Events Module Tab

The Emails module tab is typically located under the Home tab on the navigation bar at the top of MaaxFrame screen. Click the tab to access your events actvities. You may also hover on the top tab to display the menu, which allows you to perform important actions within the module.

The Actions menu allows you to perform the following options:

Menu Item | Description
---|---
Schedule Meeting | Schedule a new meeting via the Meetings edit view
Upcoming Events | Schedule the events which can be related with any source

***NOTE:  Maaxframe supports unlimited days "recycle bin" feature.  It works like your machine's recycle bin. All deleted documents are there untill you manually "delete forever" from the recycle-bin in every module.***

#### My Events Quick View

- Calendar Actions

  - When viewing your calendar, there are several options across the top of the calendar to help you navigate the calendar and increase the functionality available. These buttons are accessible from any calendar screen, with some notable exceptions. Most of the buttons are used to change the view of the calendar to show a specific time period, or jump to a specific period. The buttons are defined as follows:


![Event Module]img/events1.png)

Options | Description
---|---
Month | View the current month on the calendar
Week |  View the current week on the calendar
Today | View the current day on the calendar
User List | Select events that will be show on the calendar.


- Creating My Events Activities

  - The methods for creating the different activities available in MaaxFrame, the My Events module's actions menu. The full edit view layout opens when creating the activity from the actions menu or directly from the individual module. For more information on configuring layouts, please refer to the Technical documentation in the Administration guide.
To create an activity is via the create options in the My Events module tab. This opens up the edit view layout which allows you to enter in all the relevant information for the activity.

- Adding Invitees

  - Users have the option of adding additional invitees (i.e. Contacts, Leads, Users) to meetings via the Add Invitees Meetings . Please note that the user creating the  meeting as well as the contact or lead selected in the Related To field will automatically be added as invitees to the call or meeting.


![Event Module]img/events2.png)

- Adding Calendars

  - MaaxFrame includes the ability to include different time calendars. Calendars can be presented to users by a popup window that will appear within your MaaxFrame window or by an email being sent to all of the invitees. By default, reminders have to be manually added to meetings upon creating or editing the activity. Users can update their calendars to be specific times for each type of events through the preferences.

![Event Module]img/events3.png)

- Viewing Via Calendar

  - The Calendar module allows users to schedule, view, and manage various activities (Meetings) in MaaxFrame. The Calendar module can be accessed by clicking the Calendar module tab.

## Tasks

---

#### Overview

MaaxFrame Tasks module consists of individual tasks throughout your organization. Task records can be related to one record in most modules via the flex relate field and can also be related to a single Contact. There are various ways you can create tasks in MaaxFrame such as via the Tasks module, duplication, etc. Once the task record is created, you can view and edit information pertaining to the task via the Tasks record view. Depending on the details on the task, you may also be able to view and edit the task information via the Calendar module. Each task record may then relate to other MaaxFrame records such as accounts, contacts, opportunities, and many others. This documentation will cover how to use the Tasks module as well as the various actions and options available from within the module.

#### Task Fields

The Tasks module contains a number of stock fields which come out-of-the-box with MaaxFrame. The below definitions are suggested meanings for the fields, but the fields can be leveraged differently to best meet your organization's needs.

Fields | Description
---|---
Name | Description for the task created
Start and End Date | Starting and Ending date of task
Priority | Low, Medium, High priority of the task
Status | Define the status for the task
Related to entity | defined to connect with the leads, contacts, accounts
Posted on Caledar | different caledar types are there

*** NOTE: For more information on roles, please refer to the Role Management documentation in the Administration guide. Check with your system administrator if you do not see the Delete options.***i

#### Tasks Module Tab

The Tasks module tab is typically found by clicking the arrow to the right of the module tabs on the navigation bar. The Recently Viewed menu displays the list of tasks you last viewed in the module. The Favorites menu displays the list of tasks you most recently marked as favorites in the module.

The Actions menu allows you to perform the following operations:

Menu Option | Description
---|---
Create Tasks | Opens the record view layout to create a new task
View Tasks | Opens the list view layout to search and display tasks

#### Tasks Quick View

- Creating Tasks

  - The methods for creating tasks in MaaxFrame including via the Tasks module, Tasks dashlet. The same record view layout opens when creating the task directly from the Tasks menu and includes all of the relevant fields for your organization. For more information on configuring layouts, please refer to the Studio documentation in the Administration guide.

  ![Task1]img/tasks2.png)

- Viewing Tasks

  - There are various options available for viewing task records in MaaxFrame including via Tasks list view, Tasks record view,  dashlets, reports, and calendar. Please note that you will only be able to see task records as allowed by your team membership, user access type, and assigned roles. For more information on teams and roles, please refer to the Team Management and Role Management documentation in the Administration guide.

  ![Task]img/tasks1.png)

- Editing Tasks

  - Tasks may be edited at any time to update or add information to the record. You can make changes to existing task records via the Tasks module . The record view is available within the Tasks module and includes all of the Task fields you should need.

- Deleting Taks

  - If a task record is invalid or should no longer appear in your organization's MaaxFrame instance, it may be deleted from either the Tasks record view or list view. Deleting via the record view allows you to delete a single record while the list view allows for mass deleting multiple records at once as well as single record deletions. Deleting task records will not delete the related records and will only remove the relationship, so you may wish to also delete any related records to avoid orphaned records.
  Please note that your ability to delete tasks in MaaxFrmae may be restricted by a role. 


- Closing Tasks

  - Tasks in MaaxFrame have a status field which indicate whether a task is Open, In Progress,Waiting for Response, Closed. There are various ways users can close tasks in MaaxFrame: directly from the Tasks record view as well as from the Tasks list view. 


## CRM Dashboard

---

#### Overview

MaaxFrame CRM Home page houses the dashboard and activity stream which allows users to view pertinent record information via various dashlets and activity stream posts. Every user in MaaxFrame can configure their dashlets based on the display options and filters available from their dashboard. User's can also personalize their activity stream to only view posts specific to records that are important to them. This documentation will go over the basics of the Home page as well as the various options available to customize the Home page to best fit your individual needs.

![CRM Dashboard]img/crm1.png)

MaaxFrame's Home page dashboard is where certain dashlets are grouped together based on the information that users would like to view. The "My Dashboard" comes out-of-the-box with MaaxFrame and will display when users initially access their CRM Home page. Users have the option to modify the dashboard layout, rename dashboards, delete dashboards, as well as create new dashboards if they wish. 
There are different dashlets which can be seen under CRM such as Leads, Opportunities, Accounts, etc.

![CRM Dashboard]img/crm2.png)

Please note that administrators can restrict users from modifying their Home page layouts. For more information on how administrators can prevent Home page customizations, please refer to the Admin-Set Limitations section of this documentation.

#### Admin-Set Limitations

Users may find that some of the options described in this documentation (e.g. adding and moving dashlets) are not available when configuring their dashboards. Please note that administrators in MaaxFrame have the ability to limit how users may modify their dashlets via Settings > Groups. Reach out to your system administrator if you are not able to customize your dashboard or would like to increase the maximum number of dashlets allowed in the dashboard. Keep in mind that the changes made in Settings > Groups will be systemwide and cannot be done on an individual account basis. For more information on system settings, please refer to the System documentation in the Administration guide.


## Leads

---

#### Overview

MaaxFrame Leads module consists of individual prospects who may be interested in a product or service your organization provides. Once the lead is qualified as a sales opportunity, leads can be converted into contacts, opportunities, and accounts. There are various ways you can create leads in MaaxFrame such as via the Leads module, duplication, importing leads, etc. Once the lead record is created, you can view and edit information pertaining to the lead via the Leads record view. This documentation will go over the basics of the Leads module as well as the various options available in performing the actions related to the module.

#### Lead Fields

The Leads module contains a number of stock fields which come out of the box with MaaxFrame. The below definitions are suggested meanings for the fields, but the fields can be leveraged to best meet your organization's needs.Users with administrator or developer access have the ability to alter, remove, or add fields via Settings > Users. For more information on adding or modifying fields, please refer to the documentation in the Administration guide.

Fields | Description
---|---
Name | Lead's full name with salutation
Job Title | The lead's business title
Lead No. | This is automatically created when the lead is generated
Company | Company name of the lead is filled here
Annual Revenue | it is the total cost of revenue 
Load Demo Data | gives a checkbox for the demo data
Lead Status | The source from which this lead originated
Website | website related to lead
No. of Employess | lead company employees

Tabs | Description
---|---
Contact Information | Information related to lead contact 
Related Information | Lead Industry, Lead type, Lead source, Product
Activites Information | Related tasks and calendar with it


#### Leads Module Tab

The Leads module tab is typically located under the CRM tab on the navigation bar at the top of MaaxFrame screen. Click the tab to access the Leads list view. You may also hover on the top tab to display the menu, which allows you to perform important actions within the module.

The Actions menu allows you to perform the following operations:

Menu Item | Description
---|---
Create Lead | Opens the record view layout to create a new lead
View Leads  | Opens the list view layout to search and display leads
View Lead Reports | Displays existing drill down reports based on the Leads module

![Leads]img/Leads1.png)

If you do not see the Leads module tab in MaaxFrame, please check the following:

- The Leads module may be marked as hidden in your user preferences which will prevent the module tab from being displayed. Navigate to your user profile (upper right of MaaxFrame), click the settings tab, and check the modules section. If you see the Leads module in the Hide Modules list, simply move it to the Display Modules list. For more information on hiding and displaying modules, please refer to the Layout Options section of the Administration documentation.

- The administrator may have disabled the Leads module for your entire MaaxFrame instance. Reach out to your MaaxFrame administrator to have the Leads module displayed. For more information on displaying and hiding modules throughout MaaxFrame, please refer to the Developer Tools documentation in the Administration guide.

#### Leads Quick View

- Creating Leads

  - There are various methods for creating leads in MaaxFrame including via the Leads module, quick create, duplication, web-to-lead form. The same record view layout opens when creating the lead directly from the Leads menu and includes all of the relevant fields for your organization's leads. Please note that administrators can configure the Record View layout. For more information on configuring layouts, please refer to the documentation in the Administration guide.
 
 ***Creating Via Web-to-Lead Form*** : MaaxFrame provides a simple way to allow visitors to your website or other online location to become leads in your MaaxFrame instance. You can create a web-to-lead form in MaaxFrame and place the form on an external website. Then when a visitor to your site completes and submits the form, their information is entered into MaaxFrame as a new lead record. For more information on creating and managing web-to-lead forms, please refer to the Web-To-Lead Forms documentation.

 ![Leads]img/Leads2.png)

 ![Leads]img/Leads3.png)

 ![Leads]img/Leads4.PNG) 

- Viewing Leads

  - There are various options available for viewing lead records in MaaxFrame including via Leads list view, Leads record view, dashlets, and reports. Please note that you will only be able to see lead records as allowed by your team membership, user access type, and assigned roles. For more information on teams and roles, please refer to the Team Management and Role Management documentation in the Administration guide.

  ![Leads]img/Leads1.png)

 
- Searching Leads

  - The Leads list view includes a module search to help you locate records easily and effectively in a module-specific manner. Once the search is performed, the relevant results will be displayed in the Leads list view below. Global Search allows users to search for information across their entire MaaxFrame database as opposed to restricting search within a specific module. Please note that MaaxFrame automatically appends the wildcard character (%) to the end of your search phrase. This allows the system to retrieve all records that start with the keyword entered in the search. If you would like to broaden the search, you can use the wildcard at the beginning of your text as well (e.g. %smith). This will pull up any record that has the word “smith” in the name, regardless of how it starts or ends.

  For more information on using the various search methods as well as how wildcards are used in the different methods, please refer to the Search documentation.

- Leads List View

  - The Leads list view displays all lead records meeting the current search criteria to which your user has access. You can view the basic details of each lead within the field columns. Please note that you will only be able to see lead records as allowed by your team membership, user access type, and assigned roles. For more information on teams and roles, please refer to the Team Management and Role Management documentation in the Administration guide.

- Leads Record View

 - The Leads record view displays thorough lead information including all lead fields. Beneath the fields you can toggle between viewing a lead's subpanels of related records (Campaigns) and the lead's activity stream. The record view can be reached by clciking a lead record's link from anywhere in the application including from the Leads list view.

 Please note that you will only be able to view a lead record according to your team membership, user type, and role restrictions. For more information on teams and roles, please refer to the Team Management and Role Management documentation in the Administration guide. For more information on editing layouts, please refer to the Studio documentation in the Administration guide.

- Deleting Records

 - If a lead record is invalid or should no longer appear in your organization's MaaxFrame instance, it may be deleted from either the Leads record view or list view. Deleting via the record view allows you to delete a single record while the list view allows for mass deleting multiple records at once as well as single record deletions. Deleting lead records will not delete the related records and will only remove the relationship, so you may wish to also delete any related records to avoid orphaned records.

 Please note that your ability to delete leads in MaaxFrame may be restricted by a role. For more information on roles, please refer to the Role Management documentation in the Administration guide. Check with your system administrator if you do not see the Delete options.


- Converting Leads

 - MaaxFrame enables you to convert leads into contacts as you determine they qualify for your organization's definition of a contact (e.g. after an evaluation/qualification process or upon entering into business with the individual). When the lead is converted, a new contact record is created in MaaxFrame with a relationship to the original lead record. The Convert Lead page also gives you the option to create an account and opportunity record.

  ![Convert Leads]img/Leads5.PNG) 

- Exporting Leads

  - MaaxFrame's Export option allows users to download all fields for the selected leads to their computers as a .CSV (comma-separated values) file. This may be useful when needing to use Lead data with other software such as Microsoft Excel or to update existing records by exporting.  Due to PHP memory limitations on the server, there may be occasions when the application times out while exporting a large number of lead records. If you encounter an error when performing this action, we recommend selecting the records in smaller batches.

 Leads may be exported from the Leads list view by selecting "Export Selected" from the More menu. Users with access to the Reports module also have the option of creating or accessing reports containing specifically chosen fields for leads and their related record(s). Please note that only Rows and Columns-type reports have the ability to be exported. For more information on exporting records in MaaxFrame, please refer to the Export documentation.

 ![Export Leads]img/Leads6.PNG)

 Please note that your ability to export leads from MaaxFrame may be restricted by a role. For more information on roles, please refer to the Role Management documentation in the Administration guide. Check with your system administrator if you do not see the Export option.

- Viewing Lead Change Logs
 
 - Changes made to each lead record are tracked over time, and users are able to view the history of changes via the change log in each lead's record view. To view the change log, navigate to a lead in record view and select "Logs" inside the Actions menu. For more information on designating for audit, please refer to the documentation in the Administration guide.

  ![Leads Log]img/Leads7.PNG)

# Accounts & Contacts

## Introduction

When we say an application is modular, we generally mean it's composed of a set of highly decoupled, distinct pieces of functionality stored in modules. As you probably know, loose coupling facilitates easier maintainability of apps by removing dependencies where possible. When this is implemented efficiently, it's quite easy to see how changes to one part of a system may affect another.

Unlike some more traditional programming languages, the current iteration of JavaScript (ECMA-262) doesn't provide developers with the means to import such modules of code in a clean, organized manner. 

Instead, developers are left to fall back on variations of the module or object literal patterns combined with script tags or a script loader. With many of these, module scripts are strung together in the DOM with namespaces being described by a single global object where it's still possible to have name collisions. There's also no clean way to handle dependency management without some manual effort or third party tools.

Whilst native solutions to these problems may be arriving via [ES6](http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts) (the next version of the official JavaScript specification) [modules proposal](http://wiki.ecmascript.org/doku.php?id=harmony:modules), the good news is that writing modular JavaScript has never been easier and you can start doing it today.

In this next part of the book, we're going to look at how to use AMD modules and RequireJS to cleanly wrap units of code in your application into manageable modules. We'll also cover an alternate approach called Lumbar which uses routes to determine when modules are loaded.

## Organizing modules with RequireJS and AMD

*Partly Contributed by [Jack Franklin](https://github.com/jackfranklin)*

[RequireJS](http://requirejs.org) is a popular script loader written by James Burke - a developer who has been quite instrumental in helping shape the AMD module format, which we'll discuss shortly. Amongst other things RequireJS helps you to load multiple script files, define modules with or without dependencies, and load in non-script dependencies such as text files.

### Maintainability problems with multiple script files

You might be thinking that there is little benefit to RequireJS. After all, you can simply load in your JavaScript files through multiple `<script>` tags, which is very straightforward. However, doing it that way has a lot of drawbacks, including increasing the HTTP overhead.

Every time the browser loads in a file you've referenced in a `<script>` tag, it makes an HTTP request to load the file's contents. It has to make a new HTTP request for each file you want to load, which causes problems.

- Browsers are limited in how many parallel requests they can make, so often it's slow to load multiple files, as it can only do a certain number at a time. This number depends on the user's settings and browser, but is usually around 4-8. When working on Backbone applications it's good to split your app into multiple JS files, so it's easy to hit that limit quickly. This can be negated by minifying your code into one file as part of a build process, but does not help with the next point.
- Scripts are loaded synchronously. This means that the browser cannot continue page rendering while the script is loading, .

What tools like RequireJS do is load scripts asynchronously. This means we have to adjust our code slightly, you can't just swap out `<script>` elements for a small piece of RequireJS code, but the benefits are very worthwhile:

- Loading the scripts asynchronously means the load process is non-blocking. The browser can continue to render the rest of the page as the scripts are being loaded, speeding up the initial load time.
- We can load modules in more intelligently, having more control over when they are loaded and ensuring that modules which have dependencies are loaded in the right order.

### Need for better dependency management

Dependency management is a challenging subject, in particular when writing JavaScript in the browser. The closest thing we have to dependency management by default is simply making sure we order our `<script>` tags such that code that depends on code in another file is loaded after the file it depends on. This is not a good approach. As I've already discussed, loading multiple files in that way is bad for performance; needing them to be loaded in a certain order is very brittle.

Being able to load code on an as-needed basis is something RequireJS is very good at. Rather than load all our JavaScript code in during initial page load, a better approach is to dynamically load modules when that code is required. This avoids loading all the code when the user first hits your application, consequently speeding up initial load times.

Think about the GMail web client for a moment. When a user initially loads the page on their first visit, Google can simply hide widgets such as the chat module until the user has indicated (by clicking 'expand') that they wish to use it. Through dynamic dependency loading, Google could load up the chat module at that time, rather than forcing all users to load it when the page first initializes. This can improve performance and load times and can definitely prove useful when building larger applications. As the codebase for an application grows this becomes even more important.

The important thing to note here is that while it's absolutely fine to develop applications without a script loader, there are significant benefits to utilizing tools like RequireJS in your application.

### Asynchronous Module Definition (AMD)

RequireJS implements the [AMD Specification](https://github.com/amdjs/amdjs-api/wiki/AMD) which defines a method for writing modular code and managing dependencies. The RequireJS website also has a section [documenting the reasons behind implementing AMD](http://requirejs.org/docs/whyamd.html):

> The AMD format comes from wanting a module format that was better than today's "write a bunch of script tags with implicit dependencies that you have to manually order" and something that was easy to use directly in the browser. Something with good debugging characteristics that did not require server-specific tooling to get started.

### Writing AMD modules with RequireJS

As discussed above, the overall goal for the AMD format is to provide a solution for modular JavaScript that developers can use today. The two key concepts you need to be aware of when using it with a script-loader are the `define()` method for defining modules and the `require()` method for loading dependencies. `define()` is used to define named or unnamed modules using the following signature:

```javascript
define(
    module_id /*optional*/,
    [dependencies] /*optional*/,
    definition function /*function for instantiating the module or object*/
);
```

As you can tell by the inline comments, the `module_id` is an optional argument which is typically only required when non-AMD concatenation tools are being used (there may be some other edge cases where it's useful too). When this argument is left out, we call the module 'anonymous'. When working with anonymous modules, RequireJS will use a module's file path as its module id, so the adage Don't Repeat Yourself (DRY) should be applied by omitting the module id in the `define()` invocation.

The dependencies argument is an array representing all of the other modules that this module depends on and the third argument is a factory that can either be a function that should be executed to instantiate the module or an object. 

A barebones module (compatible with RequireJS) could be defined using `define()` as follows:

```javascript
// A module ID has been omitted here to make the module anonymous

define(['foo', 'bar'],
    // module definition function
    // dependencies (foo and bar) are mapped to function parameters
    function ( foo, bar ) {
        // return a value that defines the module export
        // (i.e the functionality we want to expose for consumption)

        // create your module here
        var myModule = {
            doStuff:function(){
                console.log('Yay! Stuff');
            }
        }

        return myModule;
});
```

*Note: RequireJS is intelligent enough to automatically infer the '.js' extension to your script file names. As such, this extension is generally omitted when specifying dependencies.*

#### Alternate syntax
There is also a [sugared version](http://requirejs.org/docs/whyamd.html#sugar) of `define()` available that allows you to declare your dependencies as local variables using `require()`. This will feel familiar to anyone who's used node, and can be easier to add or remove dependencies.
Here is the previous snippet using the alternate syntax:

```javascript
// A module ID has been omitted here to make the module anonymous

define(function(require){
        // module definition function
    // dependencies (foo and bar) are defined as local vars
    var foo = require('foo'),
        bar = require('bar');

    // return a value that defines the module export
    // (i.e the functionality we want to expose for consumption)

    // create your module here
    var myModule = {
        doStuff:function(){
            console.log('Yay! Stuff');
        }
    }

    return myModule;
});
```

The `require()` method is typically used to load code in a top-level JavaScript file or within a module should you wish to dynamically fetch dependencies. An example of its usage is:

```javascript
// Consider 'foo' and 'bar' are two external modules
// In this example, the 'exports' from the two modules loaded are passed as
// function arguments to the callback (foo and bar)
// so that they can similarly be accessed

require( ['foo', 'bar'], function ( foo, bar ) {
    // rest of your code here
    foo.doSomething();
});
```

Addy's post on [Writing Modular JS](http://addyosmani.com/writing-modular-js/) covers the AMD specification in much more detail. Defining and using modules will be covered in this book shortly when we look at more structured examples of using RequireJS.

### Getting Started with RequireJS

Before using RequireJS and Backbone we will first set up a very basic RequireJS project to demonstrate how it works. The first thing to do is to [Download RequireJS](http://requirejs.org/docs/download.html#requirejs). When you load in the RequireJS script in your HTML file, you need to also tell it where your main JavaScript file is located. Typically this will be called something like "app.js", and is the main entry point for your application. You do this by adding in a `data-main` attribute to the `script` tag:

```html
<script data-main="app" src="lib/require.js"></script>
```

Now, RequireJS will automatically load `app.js` for you.

#### RequireJS Configuration

In the main JavaScript file that you load with the `data-main` attribute you can configure how RequireJS loads the rest of your application. This is done by calling `require.config`, and passing in an object:

```javascript
require.config({
    // your configuration key/values here
    baseUrl: "app", // generally the same directory as the script used in a data-main attribute for the top level script
    paths: {}, // set up custom paths to libraries, or paths to RequireJS plugins
    shim: {}, // used for setting up all Shims (see below for more detail)
});
```

The main reason you'd want to configure RequireJS is to add shims, which we'll cover next. To see other configuration options available to you, I recommend checking out the [RequireJS documentation](http://requirejs.org/docs/api.html#config).


##### RequireJS Shims

Ideally, each library that we use with RequireJS will come with AMD support. That is, it uses the `define` method to define the library as a module. However, some libraries - including Backbone and one of its dependencies, Underscore - don't do this. Fortunately RequireJS comes with a way to work around this.

To demonstrate this, first let's shim Underscore, and then we'll shim Backbone too. Shims are very simple to implement:

```javascript
require.config({
    shim: {
        'lib/underscore': {
            exports: '_'
        }
    }
});
```

Note that when specifying paths for RequireJS you should omit the `.js` from the end of script names.

The important line here is `exports: '_'`. This line tells RequireJS that the script in `'lib/underscore.js'` creates a global variable called `_` instead of defining a module. Now when we list Underscore as a dependency RequireJS will know to give us the `_` global variable as though it was the module defined by that script. We can set up a shim for Backbone too:

```javascript
require.config({
    shim: {
        'lib/underscore': {
          exports: '_'
        },
        'lib/backbone': {
            deps: ['lib/underscore', 'jquery'],
            exports: 'Backbone'
        }
    }
});
```

Again, that configuration tells RequireJS to return the global `Backbone` variable that Backbone exports, but this time you'll notice that Backbone's dependencies are defined. This means whenever this:

```javascript
require( 'lib/backbone', function( Backbone ) {...} );
```

Is run, it will first make sure the dependencies are met, and then pass the global `Backbone` object into the callback function. You don't need to do this with every library, only the ones that don't support AMD. For example, jQuery does support it, as of jQuery 1.7.

If you'd like to read more about general RequireJS usage, the [RequireJS API docs](http://requirejs.org/docs/api.html) are incredibly thorough and easy to read.

#### Custom Paths

Typing long paths to file names like `lib/backbone` can get tedious. RequireJS lets us set up custom paths in our configuration object. Here, whenever I refer to "underscore", RequireJS will look for the file `lib/underscore.js`:

```javascript
require.config({
    paths: {
        'underscore': 'lib/underscore'
    }
});
```

Of course, this can be combined with a shim:

```javascript
require.config({
    paths: {
        'underscore': 'lib/underscore'
    },
    shim: {
        'underscore': {
          exports: '_'
        }
    }
});
```

Just make sure that you refer to the custom path in your shim settings, too. Now you can do

```javascript
require( ['underscore'], function(_) {
// code here
});
```

to shim Underscore but still use a custom path.


### Require.js and Backbone Examples

Now that we've taken a look at how to define AMD modules, let's review how to go about wrapping components like views and collections so that they can also be easily loaded as dependencies for any parts of your application that require them. At its simplest, a Backbone model may just require Backbone and Underscore.js. These are dependencies, so we can define those when defining the new modules. Note that the following examples presume you have configured RequireJS to shim Backbone and Underscore, as discussed previously.

#### Wrapping models, views, and other components with AMD

For example, here is how a model is defined.

```javascript
define(['underscore', 'backbone'], function(_, Backbone) {
  var myModel = Backbone.Model.extend({

    // Default attributes
    defaults: {
      content: 'hello world',
    },

    // A dummy initialization method
    initialize: function() {
    },

    clear: function() {
      this.destroy();
      this.view.remove();
    }

  });
  return myModel;
});
```

Note how we alias Underscore.js's instance to `_` and Backbone to just `Backbone`, making it very trivial to convert non-AMD code over to using this module format. For a view which might require other dependencies such as jQuery, this can similarly be done as follows:

```javascript
define([
  'jquery',
  'underscore',
  'backbone',
  'collections/mycollection',
  'views/myview'
  ], function($, _, Backbone, myCollection, myView){

  var AppView = Backbone.View.extend({
  ...
```

Aliasing to the dollar-sign (`$`) once again makes it very easy to encapsulate any part of an application you wish using AMD.

Doing it this way makes it easy to organize your Backbone application as you like. It's recommended to separate modules into folders. For example, individual folders for models, collections, views and so on. RequireJS doesn't care about what folder structure you use; as long as you use the correct path when using `require`, it will happily pull in the file.

As part of this chapter I've made a very simple [Backbone application with RequireJS that you can find on Github](https://github.com/javascript-playground/backbone-require-example). It is a stock application for a manager of a shop. They can add new items and filter down the items based on price, but nothing more. Because it's so simple it's easier to focus purely on the RequireJS part of the implementation, rather than deal with complex JavaScript and Backbone logic too.

At the base of this application is the `Item` model, which describes a single item in the stock. Its implementation is very straight forward:

```javascript
define( ["lib/backbone"], function ( Backbone ) {
  var Item = Backbone.Model.extend({
    defaults: {
      price: 35,
      photo: "http://www.placedog.com/100/100"
    }
  });
  return Item;
});
```

Converting an individual model, collection, view or similar into an AMD, RequireJS compliant one is typically very straight forward. Usually all that's needed is the first line, calling `define`, and to make sure that once you've defined your object - in this case, the `Item` model, to return it.

Let's now set up a view for that individual item:

```javascript
define( ["lib/backbone"], function ( Backbone ) {
  var ItemView = Backbone.View.extend({
    tagName: "div",
    className: "item-wrap",
    template: _.template($("#itemTemplate").html()),

    render: function() {
      this.$el.html(this.template(this.model.toJSON()));
      return this;
    }
  });
  return ItemView;
});
```

This view doesn't actually depend on the model it will be used with, so again the only dependency is Backbone. Other than that it's just a regular Backbone view. There's nothing special going on here, other than returning the object and using `define` so RequireJS can pick it up. Now let's make a collection to view a list of items. This time we will need to reference the `Item` model, so we add it as a dependency:

```javascript
define(["lib/backbone", "models/item"], function(Backbone, Item) {
  var Cart = Backbone.Collection.extend({
    model: Item,
    initialize: function() {
      this.on("add", this.updateSet, this);
    },
    updateSet: function() {
      items = this.models;
    }
  });
  return Cart;
});
```

I've called this collection `Cart`, as it's a group of items. As the `Item` model is the second dependency, I can bind the variable `Item` to it by declaring it as the second argument to the callback function. I can then refer to this within my collection implementation.

Finally, let's have a look at the view for this collection. (This file is much bigger in the application, but I've taken some bits out so it's easier to examine).

```javascript
define(["lib/backbone", "views/itemview"], function(Backbone, ItemView) {
  var ItemCollectionView = Backbone.View.extend({
    el: '#yourcart',
    initialize: function(collection) {
      this.collection = collection;
      this.render();
      this.collection.on("reset", this.render, this);
    },
    render: function() {
      this.$el.html("");
      this.collection.each(function(item) {
        this.renderItem(item);
      }, this);
    },
    renderItem: function(item) {
      var itemView = new ItemView({model: item});
      this.$el.append(itemView.render().el);
    },
    // more methods here removed
  });
  return ItemCollectionView;
});
```

There really is nothing to it once you've got the general pattern. Define each "object" (a model, view, collection, router or otherwise) through RequireJS, and then specify them as dependencies to other objects that need them. Again, you can find this entire application [on Github](https://github.com/javascript-playground/backbone-require-example).

If you'd like to take a look at how others do it, [Pete Hawkins' Backbone Stack repository](https://github.com/phawk/Backbone-Stack) is a good example of structuring a Backbone application using RequireJS. Greg Franko has also written [an overview of how he uses Backbone and Require](http://gregfranko.com/blog/using-backbone-dot-js-with-require-dot-js/), and [Jeremy Kahn's post](http://jeremyckahn.github.com/blog/2012/08/18/keeping-it-sane-backbone-views-and-require-dot-js/) neatly describes his approach. For a look at a full sample application, the [Backbone and Require version](https://github.com/addyosmani/todomvc/tree/gh-pages/dependency-examples/backbone_require) of the TodoMVC application is a good starting point.

### Keeping Your Templates External Using RequireJS And The Text Plugin

Moving your templates to external files is actually quite straight-forward, whether they are Underscore, Mustache, Handlebars or any other text-based template format. Let's look at how we do that with RequireJS.

RequireJS has a special plugin called text.js which is used to load in text file dependencies. To use the text plugin, follow these steps:

1. Download the plugin from http://requirejs.org/docs/download.html#text and place it in either the same directory as your application's main JS file or a suitable sub-directory.

2. Next, include the text.js plugin in your initial RequireJS configuration options. In the code snippet below, we assume that RequireJS is being included in our page prior to this code snippet being executed.

```javascript
require.config( {
    paths: {
        'text': 'libs/require/text',
    },
    baseUrl: 'app'
} );
```

3. When the `text!` prefix is used for a dependency, RequireJS will automatically load the text plugin and treat the dependency as a text resource. A typical example of this in action may look like:

```javascript
require(['js/app', 'text!templates/mainView.html'],
    function( app, mainView ) {
        // the contents of the mainView file will be
        // loaded into mainView for usage.
    }
);
```

4. Finally we can use the text resource that's been loaded for templating purposes. You're probably used to storing your HTML templates inline using a script with a specific identifier.

With Underscore.js's micro-templating (and jQuery) this would typically be:

HTML:

```html
<script type="text/template" id="mainViewTemplate">
    <% _.each( person, function( person_item ){ %>
        <li><%= person_item.get('name') %></li>
    <% }); %>
</script>
```


JS:

```javascript
var compiled_template = _.template( $('#mainViewTemplate').html() );
```

With RequireJS and the text plugin however, it's as simple as saving the same template into an external text file (say, `mainView.html`) and doing the following:

```javascript
require(['js/app', 'text!templates/mainView.html'],
    function(app, mainView){
        var compiled_template = _.template( mainView );
    }
);
```

That's it! Now you can apply your template to a view in Backbone with something like:

```javascript
collection.someview.$el.html( compiled_template( { results: collection.models } ) );
```

All templating solutions will have their own custom methods for handling template compilation, but if you understand the above, substituting Underscore's micro-templating for any other solution should be fairly trivial.


### Optimizing Backbone apps for production with the RequireJS Optimizer

Once you're written your application, the next important step is to prepare it for deployment to production. The majority of non-trivial apps are likely to consist of several scripts and so optimizing, minimizing, and concatenating your scripts prior to pushing can reduce the number of scripts your users need to download.

A command-line optimization tool for RequireJS projects called r.js is available to help with this workflow. It offers a number of capabilities, including:

* Concatenating specific scripts and minifying them using external tools such as UglifyJS (which is used by default) or Google's Closure Compiler for optimal browser delivery, whilst preserving the ability to dynamically load modules
* Optimizing CSS and stylesheets by inlining CSS files imported using @import, stripping out comments, etc.
* The ability to run AMD projects in both Node and Rhino (more on this later)

If you find yourself wanting to ship a single file with all dependencies included, r.js can help with this too. Whilst RequireJS does support lazy-loading, your application may be small enough that reducing HTTP requests to a single script file is feasible.

You'll notice that I mentioned the word 'specific' in the first bullet point. The RequireJS optimizer only concatenates module scripts that have been specified as string literals in `require` and `define` calls (which you've probably used). As clarified by the [optimizer docs](http://requirejs.org/docs/optimization.html) this means that Backbone modules defined like this:

```javascript
define(['jquery', 'backbone', 'underscore', 'collections/sample', 'views/test'],
    function($, Backbone, _, Sample, Test){
        //...
    });
```

will combine fine, however dynamic dependencies such as:

```javascript
var models = someCondition ? ['models/ab', 'models/ac'] : ['models/ba', 'models/bc'];
define(['jquery', 'backbone', 'underscore'].concat(models),
    function($, Backbone, _, firstModel, secondModel){
        //...
    });
```

will be ignored. This is by design as it ensures that dynamic dependency/module loading can still take place even after optimization.

Although the RequireJS optimizer works fine in both Node and Java environments, it's strongly recommended to run it under Node as it executes significantly faster there.

To get started with r.js, grab it from the [RequireJS download page](http://requirejs.org/docs/download.html#rjs) or [through NPM](http://requirejs.org/docs/optimization.html#download). To begin getting our project to build with r.js, we will need to create a new build profile.

Assuming the code for our application and external dependencies are in `app/libs`, our build.js build profile could simply be:

```
({
  baseUrl: 'app',
  out: 'dist/main.js',
```

The paths above are relative to the `baseUrl` for our project and in our case it would make sense to make this the `app` folder. The `out` parameter informs r.js that we want to concatenate everything into a single file called `main.js` under the `dist/` directory. Note that here we do need to add the `.js` extension to the filename. Earlier, we saw that when referencing modules by filenames, you don't need to use the `.js` extension, however this is one case in which you do.

Alternatively, we can specify `dir`, which will ensure the contents of our `app` directory are copied into this directory. e.g:

```
({
  baseUrl: 'app',
  dir: 'release',
  out: 'dist/main.js'
```

Additional options that can be specified such as `modules` and `appDir` are not compatible with `out`, however let's briefly discuss them in case you do wish to use them. 

`modules` is an array where we can explicitly specify the module names we would like to have optimized.


```
    modules: [
        {
            name: 'app',
            exclude: [
                // If you prefer not to include certain 
                // libs exclude them here
            ]
        }
```

`appDir` - when specified, our`baseUrl` is relative to this parameter. If `appDir` is not defined, `baseUrl` is simply relative to the `build.js` file.

```
    appDir: './',
```

Back to our build profile, the `main` parameter is used to specify our main module - we are making use of `include` here as we're going to take advantage of [Almond](https://github.com/jrburke/almond) - a stripped down loader for RequireJS modules which is useful should you not need to load modules in dynamically. 

```
  include: ['libs/almond', 'main'],
  wrap: true,
```

`include` is another array which specifies the modules we want to include in the build. By specifying "main", r.js will trace over all modules main depends on and will include them. `wrap` wraps modules which RequireJS needs into a closure so that only what we export is included in the global environment. 

```
  paths: {
    backbone: 'libs/backbone',
    underscore: 'libs/underscore',
    jquery: 'libs/jquery',
    text: 'libs/text'
  }
})
```
The remainder of the build.js file would be a regular paths configuration object. We can compile our project into a target file by running:

```
node r.js -o build.js
```

which should place our compiled project into dist/main.js.

The build profile is usually placed inside the 'scripts' or 'js' directory of your project. As per the docs, this file can however exist anywhere you wish, but you'll need to edit the contents of your build profile accordingly.

That's it. As long as you have UglifyJS/Closure tools setup correctly, r.js should be able to easily optimize your entire Backbone project in just a few key-strokes. 

If you would like to learn more about build profiles, James Burke has a [heavily commented sample file](https://github.com/jrburke/r.js/blob/master/build/example.build.js) with all the possible options available.







# Products & Doc Manager

In this chapter, we'll look at our first practical Backbone & RequireJS project - how to build a modular Todo application. Similar to exercise 1, the application will allow us to add new todos, edit new todos and clear todo items that have been marked as completed. For a more advanced practical, see the section on mobile Backbone development.

The complete code for the application can can be found in the `practicals/modular-todo-app` folder of this repo (thanks to Thomas Davis and J&eacute;r&ocirc;me Gravel-Niquet). Alternatively grab a copy of my side-project [TodoMVC](https://github.com/addyosmani/todomvc) which contains the sources to both AMD and non-AMD versions.

### Overview

Writing a modular Backbone application can be a straight-forward process. There are however, some key conceptual differences to be aware of if opting to use AMD as your module format of choice:

* As AMD isn't a standard native to JavaScript or the browser, it's necessary to use a script loader (such as RequireJS or curl.js) in order to support defining components and modules using this module format. As we've already reviewed, there are a number of advantages to using the AMD as well as RequireJS to assist here.
* Models, views, controllers and routers need to be encapsulated *using* the AMD-format. This allows each component of our Backbone application to cleanly manage dependencies (e.g collections required by a view) in the same way that AMD allows non-Backbone modules to.
* Non-Backbone components/modules (such as utilities or application helpers) can also be encapsulated using AMD. I encourage you to try developing these modules in such a way that they can both be used and tested independent of your Backbone code as this will increase their ability to be re-used elsewhere.

Now that we've reviewed the basics, let's take a look at developing our application. For reference, the structure of our app is as follows:

```
index.html
...js/
    main.js
    .../models
            todo.js
    .../views
            app.js
            todos.js
    .../collections
            todos.js
    .../templates
            stats.html
            todos.html
    ../libs
        .../backbone
        .../jquery
        .../underscore
        .../require
                require.js
                text.js
...css/
```

### Markup

The markup for the application is relatively simple and consists of three primary parts: an input section for entering new todo items (`create-todo`), a list section to display existing items (which can also be edited in-place) (`todo-list`) and finally a section summarizing how many items are left to be completed (`todo-stats`).

```
<div id="todoapp">

      <div class="content">

        <div id="create-todo">
          <input id="new-todo" placeholder="What needs to be done?" type="text" />
          <span class="ui-tooltip-top">Press Enter to save this task</span>
        </div>

        <div id="todos">
          <ul id="todo-list"></ul>
        </div>

        <div id="todo-stats"></div>

      </div>

</div>
```

The rest of the tutorial will now focus on the JavaScript side of the practical.

### Configuration options

If you've read the earlier chapter on AMD, you may have noticed that explicitly needing to define each dependency a Backbone module (view, collection or other module) may require with it can get a little tedious. This can however be improved.

In order to simplify referencing common paths the modules in our application may use, we use a RequireJS [configuration object](http://requirejs.org/docs/api.html#config), which is typically defined as a top-level script file. Configuration objects have a number of useful capabilities, the most useful being mode name-mapping. Name-maps are basically a key:value pair, where the key defines the alias you wish to use for a path and the value represents the true location of the path.

In the code-sample below, you can see some typical examples of common name-maps which include: `backbone`, `underscore`, `jquery` and depending on your choice, the RequireJS `text` plugin, which assists with loading text assets like templates.

**main.js**

```javascript
require.config({
  baseUrl:'../',
  paths: {
    jquery: 'libs/jquery/jquery-min',
    underscore: 'libs/underscore/underscore-min',
    backbone: 'libs/backbone/backbone-optamd3-min',
    text: 'libs/require/text'
  }
});

require(['views/app'], function(AppView){
  var app_view = new AppView;
});
```

The `require()` at the end of our main.js file is simply there so we can load and instantiate the primary view for our application (`views/app.js`). You'll commonly see both this and the configuration object included in most top-level script files for a project.

In addition to offering name-mapping, the configuration object can be used to define additional properties such as `waitSeconds` - the number of seconds to wait before script loading times out and `locale`, should you wish to load up i18n bundles for custom languages. The `baseUrl` is simply the path to use for module lookups.

For more information on configuration objects, please feel free to check out the excellent guide to them in the [RequireJS docs](http://requirejs.org/docs/api.html#config).


### Modularizing our models, views and collections

Before we dive into AMD-wrapped versions of our Backbone components, let's review a sample of a non-AMD view. The following view listens for changes to its model (a Todo item) and re-renders if a user edits the value of the item.

```javascript
var TodoView = Backbone.View.extend({

    //... is a list tag.
    tagName:  'li',

    // Cache the template function for a single item.
    template: _.template($('#item-template').html()),

    // The DOM events specific to an item.
    events: {
      'click .check'              : 'toggleDone',
      'dblclick div.todo-content' : 'edit',
      'click span.todo-destroy'   : 'clear',
      'keypress .todo-input'      : 'updateOnEnter'
    },

    // The TodoView listens for changes to its model, re-rendering. Since there's
    // a one-to-one correspondence between a **Todo** and a **TodoView** in this
    // app, we set a direct reference on the model for convenience.
    initialize: function() {
      this.model.on('change', this.render, this);
      this.model.view = this;
    },
    ...
```

Note how for templating the common practice of referencing a script by an ID (or other selector) and obtaining its value is used. This of course requires that the template being accessed is implicitly defined in our markup. The following is the 'embedded' version of our template being referenced above:

```
<script type="text/template" id="item-template">
      <div class="todo <%= done ? 'done' : '' %>">
        <div class="display">
          <input class="check" type="checkbox" <%= done ? 'checked="checked"' : '' %> />
          <div class="todo-content"></div>
          <span class="todo-destroy"></span>
        </div>
        <div class="edit">
          <input class="todo-input" type="text" value="" />
        </div>
      </div>
</script>
```

Whilst there is nothing wrong with the template itself, once we begin to develop larger applications requiring multiple templates, including them all in our markup on page-load can quickly become both unmanageable and come with performance costs. We'll look at solving this problem in a minute.

Let's now take a look at the AMD-version of our view. As discussed earlier, the 'module' is wrapped using AMD's `define()` which allows us to specify the dependencies our view requires. Using the mapped paths to 'jquery' etc. simplifies referencing common dependencies and instances of dependencies are themselves mapped to local variables that we can access (e.g 'jquery' is mapped to `$`).

**views/todo.js**

```javascript
define([
  'jquery',
  'underscore',
  'backbone',
  'text!templates/todos.html'
  ], function($, _, Backbone, todosTemplate){
  var TodoView = Backbone.View.extend({

    //... is a list tag.
    tagName:  'li',

    // Cache the template function for a single item.
    template: _.template(todosTemplate),

    // The DOM events specific to an item.
    events: {
      'click .check'              : 'toggleDone',
      'dblclick div.todo-content' : 'edit',
      'click span.todo-destroy'   : 'clear',
      'keypress .todo-input'      : 'updateOnEnter'
    },

    // The TodoView listens for changes to its model, re-rendering. Since there's
    // a one-to-one correspondence between a **Todo** and a **TodoView** in this
    // app, we set a direct reference on the model for convenience.
    initialize: function() {
      this.model.on('change', this.render, this);
      this.model.view = this;
    },

    // Re-render the contents of the todo item.
    render: function() {
      this.$el.html(this.template(this.model.toJSON()));
      this.setContent();
      return this;
    },

    // Use `jQuery.text` to set the contents of the todo item.
    setContent: function() {
      var content = this.model.get('content');
      this.$('.todo-content').text(content);
      this.input = this.$('.todo-input');
      this.input.on('blur', this.close);
      this.input.val(content);
    },
    ...
```

 From a maintenance perspective, there's nothing logically different in this version of our view, except for how we approach templating.

Using the RequireJS text plugin (the dependency marked `text`), we can actually store all of the contents for the template we looked at earlier in an external file (todos.html).

**templates/todos.html**

```html
<div class="todo <%= done ? 'done' : '' %>">
    <div class="display">
      <input class="check" type="checkbox" <%= done ? 'checked="checked"' : '' %> />
      <div class="todo-content"></div>
      <span class="todo-destroy"></span>
    </div>
    <div class="edit">
      <input class="todo-input" type="text" value="" />
    </div>
</div>
```

There's no longer a need to be concerned with IDs for the template as we can map its contents to a local variable (in this case `todosTemplate`). We then simply pass this to the Underscore.js templating function `_.template()` the same way we normally would have the value of our template script.

Next, let's look at how to define models as dependencies which can be pulled into collections. Here's an AMD-compatible model module, which has two default values: a `content` attribute for the content of a Todo item and a boolean `done` state, allowing us to trigger whether the item has been completed or not.

**models/todo.js**

```javascript
define(['underscore', 'backbone'], function(_, Backbone) {
  var TodoModel = Backbone.Model.extend({

    // Default attributes for the todo.
    defaults: {
      // Ensure that each todo created has `content`.
      content: 'empty todo...',
      done: false
    },

    initialize: function() {
    },

    // Toggle the `done` state of this todo item.
    toggle: function() {
      this.save({done: !this.get('done')});
    },

    // Remove this Todo from *localStorage* and delete its view.
    clear: function() {
      this.destroy();
      this.view.remove();
    }

  });
  return TodoModel;
});
```

As per other types of dependencies, we can easily map our model module to a local variable (in this case `Todo`) so it can be referenced as the model to use for our `TodosCollection`. This collection also supports a simple `done()` filter for narrowing down Todo items that have been completed and a `remaining()` filter for those that are still outstanding.

**collections/todos.js**

```javascript
define([
  'underscore',
  'backbone',
  'libs/backbone/localstorage',
  'models/todo'
  ], function(_, Backbone, Store, Todo){

    var TodosCollection = Backbone.Collection.extend({

    // Reference to this collection's model.
    model: Todo,

    // Save all of the todo items under the `todos` namespace.
    localStorage: new Store('todos'),

    // Filter down the list of all todo items that are finished.
    done: function() {
      return this.filter(function(todo){ return todo.get('done'); });
    },

    // Filter down the list to only todo items that are still not finished.
    remaining: function() {
      return this.without.apply(this, this.done());
    },
    ...
```

In addition to allowing users to add new Todo items from views (which we then insert as models in a collection), we ideally also want to be able to display how many items have been completed and how many are remaining. We've already defined filters that can provide us this information in the above collection, so let's use them in our main application view.

**views/app.js**

```javascript
define([
  'jquery',
  'underscore',
  'backbone',
  'collections/todos',
  'views/todo',
  'text!templates/stats.html'
  ], function($, _, Backbone, Todos, TodoView, statsTemplate){

  var AppView = Backbone.View.extend({

    // Instead of generating a new element, bind to the existing skeleton of
    // the App already present in the HTML.
    el: $('#todoapp'),

    // Our template for the line of statistics at the bottom of the app.
    statsTemplate: _.template(statsTemplate),

    // ...events, initialize() etc. can be seen in the complete file

    // Re-rendering the App just means refreshing the statistics -- the rest
    // of the app doesn't change.
    render: function() {
      var done = Todos.done().length;
      this.$('#todo-stats').html(this.statsTemplate({
        total:      Todos.length,
        done:       Todos.done().length,
        remaining:  Todos.remaining().length
      }));
    },
    ...
```

Above, we map the second template for this project, `templates/stats.html` to `statsTemplate` which is used for rendering the overall `done` and `remaining` states. This works by simply passing our template the length of our overall Todos collection (`Todos.length` - the number of Todo items created so far) and similarly the length (counts) for items that have been completed (`Todos.done().length`) or are remaining (`Todos.remaining().length`).

The contents of our `statsTemplate` can be seen below. It's nothing too complicated, but does use ternary conditions to evaluate whether we should state there's "1 item" or "2 item<i>s</i>" in a particular state.

```
<% if (total) { %>
        <span class="todo-count">
          <span class="number"><%= remaining %></span>
          <span class="word"><%= remaining == 1 ? 'item' : 'items' %></span> left.
        </span>
      <% } %>
      <% if (done) { %>
        <span class="todo-clear">
          <a href="#">
            Clear <span class="number-done"><%= done %></span>
            completed <span class="word-done"><%= done == 1 ? 'item' : 'items' %></span>
          </a>
        </span>
      <% } %>
```



The rest of the source for the Todo app mainly consists of code for handling user and application events, but that rounds up most of the core concepts for this practical.

To see how everything ties together, feel free to grab the source by cloning this repo or browse it [online](https://github.com/addyosmani/backbone-fundamentals/tree/master/practicals/modular-todo-app) to learn more. I hope you find it helpful!

**Note:** While this first practical doesn't use a build profile as outlined in the chapter on using the RequireJS optimizer, we will be using one in the section on building mobile Backbone applications.

## Route-based module loading

This section will discuss a route based approach to module loading as implemented in [Lumbar](http://walmartlabs.github.com/lumbar) by Kevin Decker. Like RequireJS, Lumbar is also a modular build system, but the pattern it implements for loading routes may be used with any build system.

The specifics of the Lumbar build tool are not discussed in this book. To see a complete Lumbar based project with the loader and build system see [Thorax](http://thoraxjs.org) which provides boilerplate projects for various environments including Lumbar.

### JSON-based module configuration

RequireJS defines dependencies per file, while Lumbar defines a list of files for each module in a central JSON configuration file, outputting a single JavaScript file for each defined module. Lumbar requires that each module (except the base module) define a single router and a list of routes. An example file might look like:

     {
        "modules": {
            "base": {
                "scripts": [
                    "js/lib/underscore.js",
                    "js/lib/backbone.js",
                    "etc"
                ]
            },
            "pages": {
                "scripts": [
                    "js/routers/pages.js",
                    "js/views/pages/index.js",
                    "etc"
                ],
                "routes": {
                    "": "index",
                    "contact": "contact"
                }
            }
        }
    }

Every JavaScript file defined in a module will have a `module` object in scope which contains the `name` and `routes` for the module. In `js/routers/pages.js` we could define a Backbone router for our `pages` module like so:

    new (Backbone.Router.extend({
        routes: module.routes,
        index: function() {},
        contact: function() {}
    }));

### Module loader Router

A little used feature of `Backbone.Router` is its ability to create multiple routers that listen to the same set of routes. Lumbar uses this feature to create a router that listens to all routes in the application. When a route is matched, this master router checks to see if the needed module is loaded. If the module is already loaded, then the master router takes no action and the router defined by the module will handle the route. If the needed module has not yet been loaded, it will be loaded, then `Backbone.history.loadUrl` will be called. This reloads the route, causes the master router to take no further action and the router defined in the freshly loaded module to respond.

A sample implementation is provided below. The `config` object would need to contain the data from our sample configuration JSON file above, and the `loader` object would need to implement `isLoaded` and `loadModule` methods. Note that Lumbar provides all of these implementations, the examples are provided to create your own implementation.

    // Create an object that will be used as the prototype
    // for our master router
    var handlers = {
        routes: {}
    };

    _.each(config.modules, function(module, moduleName) {
        if (module.routes) {
            // Generate a loading callback for the module
            var callbackName = "loader_" moduleName;
            handlers[callbackName] = function() {
                if (loader.isLoaded(moduleName)) {
                    // Do nothing if the module is loaded
                    return;
                } else {
                    //the module needs to be loaded
                    loader.loadModule(moduleName, function() {
                        // Module is loaded, reloading the route
                        // will trigger callback in the module's
                        // router
                        Backbone.history.loadUrl();
                    });
                }
            };
            // Each route in the module should trigger the
            // loading callback
            _.each(module.routes, function(methodName, route) {
                handlers.routes[route] = callbackName;
            });
        }
    });

    // Create the master router
    new (Backbone.Router.extend(handlers));

### Using NodeJS to handle pushState

`window.history.pushState` support (serving Backbone routes without a hash mark) requires that the server be aware of what URLs your Backbone application will handle, since the user should be able to enter the app at any of those routes (or hit reload after navigating to a pushState URL).

Another advantage to defining all routes in a single location is that the same JSON configuration file provided above could be loaded by the server, listening to each route. A sample implementation in NodeJS and Express:

    var fs = require('fs'),
        _ = require('underscore'),
        express = require('express'),
        server = express(),
        config = JSON.parse(fs.readFileSync('path/to/config.json'));

    _.each(config.modules, function(module, moduleName) {
        if (module.routes) {
            _.each(module.routes, function(methodName, route) {
                server.get(route, function(req, res) {
                      res.sendFile('public/index.html');
                });
            });
        }
    });

This assumes that index.html will be serving out your Backbone application. The `Backbone.History` object can handle the rest of the routing logic as long as a `root` option is specified. A sample configuration for a simple application that lives at the root might look like:

    Backbone.history || (Backbone.history = new Backbone.History());
    Backbone.history.start({
      pushState: true,
      root: '/'
    });


## An asset package alternative for dependency management

For more than trivial views, DocumentCloud have a home-built asset packager called [Jammit](https://github.com/documentcloud/jammit), which has easy integration with Underscore.js templates and can also be used for dependency management.

Jammit expects your JavaScript templates (JST) to live alongside any ERB templates you're using in the form of .jst files. It packages the templates into a global JST object which can be used to render templates into strings. Making Jammit aware of your templates is straight-forward - just add an entry for something like `views/**/*.jst` to your app package in assets.yml.

To provide Jammit dependencies you simply write out an assets.yml file that either listed the dependencies in order or used a combination of free capture directories (for example: /**/*.js, templates/*.js, and specific files). 

A template using Jammit can derive it's data from the collection object that is passed to it:

```
this.$el.html(JST.myTemplate({ collection: this.collection }));
```

# Marketing & Campaign


Pagination is a ubiquitous problem we often find ourselves needing to solve on the web - perhaps most predominantly when working with service APIs and JavaScript-heavy clients which consume them. It's also a problem that is often under-refined as most of us consider pagination relatively easy to get right. This isn't however always the case as pagination tends to get more tricky than it initially seems. 

Before we dive into solutions for paginating data for your Backbone applications, let's define exactly what we consider pagination to be:

Pagination is a control system allowing users to browse through pages of search results (or any type of content) which is continued. Search results are the canonical example, but pagination today is found on news sites, blogs, and discussion boards, often in the form of Previous and Next links. More complete pagination systems offer granular control of the specific pages you can navigate to, giving the user more power to find what they are looking for. 

It isn't a problem limited to pages requiring some visual controls for pagination either - sites like Facebook, Pinterest, and Twitter have demonstrated that there are many contexts where infinite paging is also useful. Infinite paging is, of course, when we pre-fetch (or appear to pre-fetch) content from a subsequent page and add it directly to the user’s current page, making the experience feel "infinite".

Pagination is very context-specific and depends on the content being displayed. In the Google search results, pagination is important as they want to offer you the most relevant set of results in the first 1-2 pages. After that, you might be a little more selective (or random) with the page you choose to navigate to. This differs from cases where you'll want to cycle through consecutive pages for (e.g., for a news article or blog post). 

Pagination is almost certainly content and context-specific, but as Faruk Ates has [previously](https://gist.github.com/mislav/622561) pointed out the principles of good pagination apply no matter what the content or context is. As with everything extensible when it comes to Backbone, you can write your own pagination to address many of these content-specific types of pagination problems. That said, you'll probably spend quite a bit of time on this and sometimes you just want to use a tried and tested solution that just works.

On this topic, we're going to go through a set of pagination components I (and a group of [contributors](https://github.com/addyosmani/backbone.paginator/contributors)) wrote for Backbone.js, which should hopefully come in useful if you're working on applications which need to page Backbone Collections. They're part of an extension called [Backbone.Paginator](http://github.com/addyosmani/backbone.paginator).

### Backbone.Paginator

When working with data on the client-side, the three types of pagination we are most likely to run into are:

**Requests to a service layer (API)** - For example, query for results containing the term 'Paul' - if 5,000 results are available only display 20 results per page (leaving us with 250 possible result pages that can be navigated to).

This problem actually has quite a great deal more to it, such as maintaining persistence of other URL parameters (e.g sort, query, order) which can change based on a user's search configuration in a UI. One also has to think of a clean way of hooking views up to this pagination so you can easily navigate between pages (e.g., First, Last, Next, Previous, 1,2,3), manage the number of results displayed per page and so on.

**Further client-side pagination of data returned -** e.g we've been returned a JSON response containing 100 results. Rather than displaying all 100 to the user, we only display 20 of these results within a navigable UI in the browser.

Similar to the request problem, client-pagination has its own challenges like navigation once again (Next, Previous, 1,2,3), sorting, order, switching the number of results to display per page and so on.

**Infinite results** - with services such as Facebook, the concept of numeric pagination is instead replaced with a 'Load More' or 'View More' button. Triggering this normally fetches the next 'page' of N results but rather than replacing the previous set of results loaded entirely, we simply append to them instead.

A request pager which simply appends results in a view rather than replacing on each new fetch is effectively an 'infinite' pager.

**Let's now take a look at exactly what we're getting out of the box:**

Backbone.Paginator is a set of opinionated components for paginating collections of data using Backbone.js. It aims to provide both solutions for assisting with pagination of requests to a server (e.g an API) as well as pagination of single-loads of data, where we may wish to further paginate a collection of N results into M pages within a view.

![](img/paginator-ui.png)

Backbone.Paginator supports two main pagination components:

* **Backbone.Paginator.requestPager**: For pagination of requests between a client and a server-side API
* **Backbone.Paginator.clientPager**: For pagination of data returned from a server which you would like to further paginate within the UI (e.g 60 results are returned, paginate into 3 pages of 20)

### Live Examples

If you would like to look at examples built using the components included in the project, links to official demos are included below and use the Netflix API so that you can see them working with an actual data source.

* [Backbone.Paginator.requestPager()](http://addyosmani.github.com/backbone.paginator/examples/netflix-request-paging/index.html)
* [Backbone.Paginator.clientPager()](http://addyosmani.github.com/backbone.paginator/examples/netflix-client-paging/index.html)
* [Infinite Pagination (Backbone.Paginator.requestPager())](http://addyosmani.github.com/backbone.paginator/examples/netflix-infinite-paging/index.html)
* [Diacritic Plugin](http://addyosmani.github.com/backbone.paginator/examples/google-diacritic/index.html)

##Paginator.requestPager

In this section we're going to walk through using the requestPager. You would use this component when working with a service API which itself supports pagination. This component allows users to control the pagination settings for requests to this API (i.e navigate to the next, previous, N pages) via the client-side. 

The idea is that pagination, searching, and filtering of data can all be done from your Backbone application without the need for a page reload. 

![](img/paginator-request.png)

####1. Create a new Paginated collection

First, we define a new Paginated collection using `Backbone.Paginator.requestPager()` as follows:

```javascript

var PaginatedCollection = Backbone.Paginator.requestPager.extend({

```

####2. Set the model for the collection as normal

Within our collection, we then (as normal) specify the model to be used with this collection followed by the URL (or base URL) for the service providing our data (e.g the Netflix API).

```javascript

        model: model,
```

####3. Configure the base URL and the type of the request

We need to set a base URL. The `type` of the request is `GET` by default, and the `dataType` is `jsonp` in order to enable cross-domain requests.

```javascript
    paginator_core: {
      // the type of the request (GET by default)
      type: 'GET',

      // the type of reply (jsonp by default)
      dataType: 'jsonp',

      // the URL (or base URL) for the service
      // if you want to have a more dynamic URL, you can make this a function
      // that returns a string
      url: 'http://odata.netflix.com/Catalog/People(49446)/TitlesActedIn?'
    },
```

## Gotchas!

If you use `dataType` **NOT** jsonp, please remove the callback custom parameter inside the `server_api` configuration.

####4. Configure how the library will show the results

We need to tell the library how many items per page we would like to see, etc...

```javascript
    paginator_ui: {
      // the lowest page index your API allows to be accessed
      firstPage: 0,

      // which page should the paginator start from
      // (also, the actual page the paginator is on)
      currentPage: 0,

      // how many items per page should be shown
      perPage: 3,

      // a default number of total pages to query in case the API or
      // service you are using does not support providing the total
      // number of pages for us.
      // 10 as a default in case your service doesn't return the total
      totalPages: 10
    },
```

####5. Configure the parameters we want to send to the server

Only the base URL won't be enough for most cases, so you can pass more parameters to the server.
Note how you can use functions instead of hardcoded values, and you can also refer to the values you specified in `paginator_ui`.

```javascript
    server_api: {
      // the query field in the request
      '$filter': '',

      // number of items to return per request/page
      '$top': function() { return this.perPage },

      // how many results the request should skip ahead to
      // customize as needed. For the Netflix API, skipping ahead based on
      // page * number of results per page was necessary.
      '$skip': function() { return this.currentPage * this.perPage },

      // field to sort by
      '$orderby': 'ReleaseYear',

      // what format would you like to request results in?
      '$format': 'json',

      // custom parameters
      '$inlinecount': 'allpages',
      '$callback': 'callback'
    },
```

## Gotchas!

If you use `$callback`, please ensure that you did use the jsonp as a `dataType` inside your `paginator_core` configuration.

####6. Finally, configure Collection.parse() and we're done

The last thing we need to do is configure our collection's `parse()` method. We want to ensure we're returning the correct part of our JSON response containing the data our collection will be populated with, which below is `response.d.results` (for the Netflix API).

You might also notice that we're setting `this.totalPages` to the total page count returned by the API. This allows us to define the maximum number of (result) pages available for the current/last request so that we can clearly display this in the UI. It also allows us to influence whether clicking say, a 'next' button should proceed with a request or not.

```javascript
        parse: function (response) {
            // Be sure to change this based on how your results
            // are structured (e.g d.results is Netflix specific)
            var tags = response.d.results;
            //Normally this.totalPages would equal response.d.__count
            //but as this particular NetFlix request only returns a
            //total count of items for the search, we divide.
            this.totalPages = Math.ceil(response.d.__count / this.perPage);
            return tags;
        }
    });

});
```

####Convenience methods:

For your convenience, the following methods are made available for use in your views to interact with the `requestPager`:

* **Collection.goTo( n, options )** - go to a specific page
* **Collection.nextPage( options )** - go to the next page
* **Collection.prevPage( options )** - go to the previous page
* **Collection.howManyPer( n )** - set the number of items to display per page

**requestPager** collection's methods `.goTo()`, `.nextPage()` and `.prevPage()` are all extensions of the original [Backbone Collection.fetch() methods](http://documentcloud.github.com/backbone/#Collection-fetch). As so, they all can take the same option object as a parameter.

This option object can use `success` and `error` parameters to pass a function to be executed after server answer.

```javascript
Collection.goTo(n, {
  success: function( collection, response ) {
    // called is server request success
  },
  error: function( collection, response ) {
    // called if server request fail
  }
});
```

To manage callback, you could also use the [jqXHR](http://api.jquery.com/jQuery.ajax/#jqXHR) returned by these methods to manage callback.

```javascript
Collection
  .requestNextPage()
  .done(function( data, textStatus, jqXHR ) {
    // called is server request success
  })
  .fail(function( data, textStatus, jqXHR ) {
    // called if server request fail
  })
  .always(function( data, textStatus, jqXHR ) {
    // do something after server request is complete
  });
});
```

If you'd like to add the incoming models to the current collection, instead of replacing the collection's contents, pass `{update: true, remove: false}` as options to these methods.

```javascript
Collection.prevPage({ update: true, remove: false });
```

##Paginator.clientPager


The clientPager is used to further paginate data that has already been returned by the service API. Say you've requested 100 results from the service and wish to split this into 5 pages of paginated results, each containing 20 results at a client level - the clientPager makes it trivial to do this.

![](img/paginator-client.png)

Use the clientPager when you prefer to get results in a single "load" and thus avoid making additional network requests each time your users want to fetch the next "page" of items. As the results have all already been requested, it's just a case of switching between the ranges of data actually presented to the user.

####1. Create a new paginated collection with a model and URL

As with `requestPager`, let's first create a new Paginated `Backbone.Paginator.clientPager` collection, with a model:

```javascript
    var PaginatedCollection = Backbone.Paginator.clientPager.extend({

        model: model,
```

####2. Configure the base URL and the type of the request

We need to set a base URL. The `type` of the request is `GET` by default, and the `dataType` is `jsonp` in order to enable cross-domain requests.

```javascript
    paginator_core: {
      // the type of the request (GET by default)
      type: 'GET',

      // the type of reply (jsonp by default)
      dataType: 'jsonp',

      // the URL (or base URL) for the service
      url: 'http://odata.netflix.com/v2/Catalog/Titles?&'
    },
```

####3. Configure how the library will show the results

We need to tell the library how many items per page we would like to see, etc...

```javascript
    paginator_ui: {
      // the lowest page index your API allows to be accessed
      firstPage: 1,

      // which page should the paginator start from
      // (also, the actual page the paginator is on)
      currentPage: 1,

      // how many items per page should be shown
      perPage: 3,

      // a default number of total pages to query in case the API or
      // service you are using does not support providing the total
      // number of pages for us.
      // 10 as a default in case your service doesn't return the total
      totalPages: 10,

      // The total number of pages to be shown as a pagination
      // list is calculated by (pagesInRange * 2) + 1.
      pagesInRange: 4
    },
```

####4. Configure the parameters we want to send to the server

Only the base URL won't be enough for most cases, so you can pass more parameters to the server.
Note how you can use functions instead of hardcoded values, and you can also refer to the values you specified in `paginator_ui`.

```javascript
    server_api: {
      // the query field in the request
      '$filter': 'substringof(\'america\',Name)',

      // number of items to return per request/page
      '$top': function() { return this.perPage },

      // how many results the request should skip ahead to
      // customize as needed. For the Netflix API, skipping ahead based on
      // page * number of results per page was necessary.
      '$skip': function() { return this.currentPage * this.perPage },

      // field to sort by
      '$orderby': 'ReleaseYear',

      // what format would you like to request results in?
      '$format': 'json',

      // custom parameters
      '$inlinecount': 'allpages',
      '$callback': 'callback'
    },
```

####5. Finally, configure Collection.parse() and we're done

And finally we have our `parse()` method, which in this case isn't concerned with the total number of result pages available on the server as we have our own total count of pages for the paginated data in the UI.

```javascript
    parse: function (response) {
            var tags = response.d.results;
            return tags;
        }

    });
```

####Convenience methods:

As mentioned, your views can hook into a number of convenience methods to navigate around UI-paginated data. For `clientPager` these include:

* **Collection.goTo(n, options)** - go to a specific page
* **Collection.prevPage(options)** - go to the previous page
* **Collection.nextPage(options)** - go to the next page
* **Collection.howManyPer(n)** - set how many items to display per page
* **Collection.setSort(sortBy, sortDirection)** - update sort on the current view. Sorting will automatically detect if you're trying to sort numbers (even if they're strored as strings) and will do the right thing.
* **Collection.setFilter(filterFields, filterWords)** - filter the current view. Filtering supports multiple words without any specific order, so you'll basically get a full-text search ability. Also, you can pass it only one field from the model, or you can pass an array with fields and all of them will get filtered. Last option is to pass it an object containing a comparison method and rules. Currently, only ```levenshtein``` method is available.

The `goTo()`, `prevPage()`, and `nextPage()` functions do not require the `options` param since they will be executed synchronously. However, when specified, the success callback will be invoked before the function returns. For example:

```javascript
nextPage(); // this works just fine!
nextPage({success: function() { }}); // this will call the success function
```

The options param exists to preserve (some) interface unification between the requestPaginator and clientPaginator so that they may be used interchangeably in your Backbone.Views.

```javascript
  this.collection.setFilter(
    {'Name': {cmp_method: 'levenshtein', max_distance: 7}}
    , "Amreican P" // Note the switched 'r' and 'e', and the 'P' from 'Pie'
  );
```

Also note that the Levenshtein plugin should be loaded and enabled using the ```useLevenshteinPlugin``` variable.
Last but not less important: performing Levenshtein comparison returns the ```distance``` between two strings. It won't let you *search* lengthy text.
The distance between two strings means the number of characters that should be added, removed or moved to the left or to the right so the strings get equal.
That means that comparing "Something" in "This is a test that could show something" will return 32, which is bigger than comparing "Something" and "ABCDEFG" (9).
Use Levenshtein only for short texts (titles, names, etc).

* **Collection.doFakeFilter(filterFields, filterWords)** - returns the models count after fake-applying a call to ```Collection.setFilter```.

* **Collection.setFieldFilter(rules)** - filter each value of each model according to `rules` that you pass as argument. Example: You have a collection of books with 'release year' and 'author'. You can filter only the books that were released between 1999 and 2003. And then you can add another `rule` that will filter those books only to authors who's name start with 'A'. Possible rules: function, required, min, max, range, minLength, maxLength, rangeLength, oneOf, equalTo, containsAllOf, pattern.  Passing this an empty rules set will remove any FieldFilter rules applied.


```javascript

  my_collection.setFieldFilter([
    {field: 'release_year', type: 'range', value: {min: '1999', max: '2003'}},
    {field: 'author', type: 'pattern', value: new RegExp('A*', 'igm')}
  ]);

  //Rules:
  //
  //var my_var = 'green';
  //
  //{field: 'color', type: 'equalTo', value: my_var}
  //{field: 'color', type: 'function', value: function(field_value){ return field_value == my_var; } }
  //{field: 'color', type: 'required'}
  //{field: 'number_of_colors', type: 'min', value: '2'}
  //{field: 'number_of_colors', type: 'max', value: '4'}
  //{field: 'number_of_colors', type: 'range', value: {min: '2', max: '4'} }
  //{field: 'color_name', type: 'minLength', value: '4'}
  //{field: 'color_name', type: 'maxLength', value: '6'}
  //{field: 'color_name', type: 'rangeLength', value: {min: '4', max: '6'}}
  //{field: 'color_name', type: 'oneOf', value: ['green', 'yellow']}
  //{field: 'color_name', type: 'pattern', value: new RegExp('gre*', 'ig')}
  //{field: 'color_name', type: 'containsAllOf', value: ['green', 'yellow', 'blue']}
```

* **Collection.doFakeFieldFilter(rules)** - returns the models count after fake-applying a call to ```Collection.setFieldFilter```.

####Implementation notes:

You can use some variables in your ```View``` to represent the actual state of the paginator.

* ```totalUnfilteredRecords``` - Contains the number of records, including all records filtered in any way. (Only available in ```clientPager```)
* ```totalRecords``` - Contains the number of records
* ```currentPage``` - The actual page were the paginator is at.
* ```perPage``` - The number of records the paginator will show per page.
* ```totalPages``` - The number of total pages.
* ```startRecord``` - The position of the first record shown in the current page (eg 41 to 50 from 2000 records) (Only available in ```clientPager```)
* ```endRecord``` - The position of the last record shown in the current page (eg 41 to 50 from 2000 records) (Only available in ```clientPager```)
* ```pagesInRange``` - The number of pages to be drawn on each side of the current page. So if ```pagesInRange``` is 3 and ```currentPage``` is 13 you will get the numbers 10, 11, 12, 13(selected), 14, 15, 16.

```html
<!-- sample template for pagination UI -->
<script type="text/html" id="tmpServerPagination">

  <div class="row-fluid">

    <div class="pagination span8">
      <ul>
        <% _.each (pageSet, function (p) { %>
        <% if (currentPage == p) { %>
          <li class="active"><span><%= p %></span></li>
        <% } else { %>
          <li><a href="#" class="page"><%= p %></a></li>
        <% } %>
        <% }); %>
      </ul>
    </div>

    <div class="pagination span4">
      <ul>
        <% if (currentPage > firstPage) { %>
          <li><a href="#" class="serverprevious">Previous</a></li>
        <% }else{ %>
          <li><span>Previous</span></li>
        <% }%>
        <% if (currentPage < totalPages) { %>
          <li><a href="#" class="servernext">Next</a></li>
        <% } else { %>
          <li><span>Next</span></li>
        <% } %>
        <% if (firstPage != currentPage) { %>
          <li><a href="#" class="serverfirst">First</a></li>
        <% } else { %>
          <li><span>First</span></li>
        <% } %>
        <% if (totalPages != currentPage) { %>
          <li><a href="#" class="serverlast">Last</a></li>
        <% } else { %>
          <li><span>Last</span></li>
        <% } %>
      </ul>
    </div>

  </div>

  <span class="cell serverhowmany"> Show <a href="#"
    class="selected">18</a> | <a href="#" class="">9</a> | <a href="#" class="">12</a> per page
  </span>

  <span class="divider">/</span>

  <span class="cell first records">
    Page: <span class="label"><%= currentPage %></span> of <span class="label"><%= totalPages %></span> shown
  </span>

</script>
```

### Plugins

**Diacritic.js**

A plugin for Backbone.Paginator that replaces diacritic characters (`´`, `˝`, `̏`, `˚`,`~` etc.) with characters that match them most closely. This is particularly useful for filtering.

![](img/paginator-dia.png)

To enable the plugin, set `this.useDiacriticsPlugin` to true, as can be seen in the example below:

```javascript
Paginator.clientPager = Backbone.Collection.extend({

    // Default values used when sorting and/or filtering.
    initialize: function(){
      this.useDiacriticsPlugin = true; // use diacritics plugin if available
    ...
```

### Bootstrapping

By default, both the clientPager and requestPager will make an initial request to the server in order to populate their internal paging data. In order to avoid this additional request, it may be beneficial to bootstrap your Backbone.Paginator instance from data that already exists in the dom.

**Backbone.Paginator.clientPager:**

```javascript

// Extend the Backbone.Paginator.clientPager with your own configuration options
var MyClientPager =  Backbone.Paginator.clientPager.extend({paginator_ui: {}});
// Create an instance of your class and populate with the models of your entire collection
var aClientPager = new MyClientPager([{id: 1, title: 'foo'}, {id: 2, title: 'bar'}]);
// Invoke the bootstrap function
aClientPager.bootstrap();
```

Note: If you intend to bootstrap a clientPager, there is no need to specify a 'paginator_core' object in your configuration (since you should have already populated the clientPager with the entirety of its necessary data)

**Backbone.Paginator.requestPager:**

```javascript

// Extend the Backbone.Paginator.requestPager with your own configuration options
var MyRequestPager =  Backbone.Paginator.requestPager.extend({paginator_ui: {}});
// Create an instance of your class with the first page of data
var aRequestPager = new MyRequestPager([{id: 1, title: 'foo'}, {id: 2, title: 'bar'}]);
// Invoke the bootstrap function and configure requestPager with 'totalRecords'
aRequestPager.bootstrap({totalRecords: 50});
```

Note: Both the clientPager and requestPager ```bootstrap``` function will accept an options param that will be extended by your Backbone.Paginator instance. However the 'totalRecords' property will be set implicitly by the clientPager.

[More on Backbone bootstrapping](http://ricostacruz.com/backbone-patterns/#bootstrapping_data)

### Styling

You're of course free to customize the overall look and feel of the paginators as much as you wish. By default, all sample applications make use of the [Twitter Bootstrap](http://twitter.github.com/bootstrap) for styling links, buttons and drop-downs. 

CSS classes are available to style record counts, filters, sorting and more:

![](img/paginator-styling2.png)

Classes are also available for styling more granular elements like page counts within `breadcrumb > pages`  e.g `.page`, `.page selected`:

![](img/paginator-classes.png)

There's a tremendous amount of flexibility available for styling and as you're in control of templating too, your paginators can be made to look as visually simple or complex as needed.

### Conclusions

Although it's certainly possible to write your own custom pagination classes to work with Backbone Collections, Backbone.Paginator tries to take care of much of this for you. 

It's highly configurable, avoiding the need to write your own paging when working with Collections of data sourced from your database or API. Use the plugin to help tame large lists of data into more manageable, easily navigatable, paginated lists. 

Additionally, if you have any questions about Backbone.Paginator (or would like to help improve it), feel free to post to the project [issues](https://github.com/addyosmani/backbone.paginator) list.

# Drill Down Reports

Boilerplates provide us a starting point for working on projects. They're a base for building upon using the minimum required code to get something functional put together. When you're working on a new Backbone application, a new Model typically only takes a few lines of code to get working. 

That alone probably isn't enough however, as you'll need a Collection to group those models, a View to render them and perhaps a router if you're looking to making specific views of your Collection data bookmarkable. If you're starting on a completely fresh project, you may also need a build process in place to produce an optimized version of your app that can be pushed to production.

This is where boilerplate solutions are useful. Rather than having to manually write out the initial code for each piece of your Backbone app, a boilerplate could do this for you, also ideally taking care of the build process.

[Backbone Boilerplate](https://github.com/tbranyen/backbone-boilerplate/) (or just BB) provides just this. It is an excellent set of best practices and utilities for building Backbone.js applications, created by Backbone contributor [Tim Branyen](https://github.com/tbranyen). He took the the gotchas, pitfalls and common tasks he ran into while heavily using Backbone to build apps and crafted BB as a result of this experience.

[Grunt-BBB or Boilerplate Build Buddy](https://github.com/backbone-boilerplate/grunt-bbb) is the companion tool to BB, which offers scaffolding, file watcher and build capabilities. Used together with BB it provides an excellent base for quickly starting new Backbone applications.

![](img/bbb.png)

Out of the box, BB and Grunt-BBB provide provide us with:

* Backbone, [Lodash](https://github.com/bestiejs/lodash) (an [Underscore.js](http://underscorejs.org/) alternative) and [jQuery](http://jquery.com) with an [HTML5 Boilerplate](http://html5boilerplate.com) foundation
* Boilerplate and scaffolding support, allowing us to spend minimal time writing boilerplate for modules, collections and so on.
* A build tool for template pre-compilation and, concatenation & minification of all our libraries, application code and stylesheets
* A Lightweight node.js webserver

Notes on build tool steps:

* Template pre-compilation: using a template library such as Underscore micro-templating or Handlebars.js generally involves three steps: (1) reading a raw template, (2) compiling it into a JavaScript function and (3) running the compiled template with your desired data. Precompiling eliminates the second step from runtime, by moving this process into a build step.
* Concatenation is the process of combining a number of assets (in our case, script files) into a single (or fewer number) of files to reduce the number of HTTP requests required to obtain them.
* Minification is the process of removing unnecessary characters (e.g white space, new lines, comments) from code and compressing it to reduce the overall size of the scripts being served.

## Getting Started

### Backbone Boilerplate and Grunt-BBB

To get started we're going to install Grunt-BBB, which will include Backbone Boilerplate and any third-party dependencies it might need such as the Grunt build tool. 

We can install Grunt-bBB via NPM by running:

```shell
npm install -g bbb
```

That's it. We should now be good to go.

A typical workflow for using grunt-bbb, which we will use later on is:

* Initialize a new project (`bbb init`)
* Add new modules and templates (`bbb init:module`)
* Preview changes using the built in server (`bbb server`)
* Run the build tool (`bbb build`)
* Lint JavaScript, compile templates, build your application using r.js, minify CSS and JavaScript (using `bbb release`)

## Creating a new project

Let's create a new directory for our project and run `bbb init` to kick things off. A number of project sub-directories and files will be stubbed out for us, as shown below:

```shell
$ bbb init
Running "init" task
This task will create one or more files in the current directory, based on the
environment and the answers to a few questions. Note that answering "?" to any
question will show question-specific help and answering "none" to most questions
will leave its value blank.

"bbb" template notes:
This tool will help you install, configure, build, and maintain your Backbone
Boilerplate project.
Writing app/app.js...OK
Writing app/config.js...OK
Writing app/main.js...OK
Writing app/router.js...OK
Writing app/styles/index.css...OK
Writing favicon.ico...OK
Writing grunt.js...OK
Writing index.html...OK
Writing package.json...OK
Writing readme.md...OK
Writing test/jasmine/index.html...OK
Writing test/jasmine/spec/example.js...OK
Writing test/jasmine/vendor/jasmine-html.js...OK
Writing test/jasmine/vendor/jasmine.css...OK
Writing test/jasmine/vendor/jasmine.js...OK
Writing test/jasmine/vendor/jasmine_favicon.png...OK
Writing test/jasmine/vendor/MIT.LICENSE...OK
Writing test/qunit/index.html...OK
Writing test/qunit/tests/example.js...OK
Writing test/qunit/vendor/qunit.css...OK
Writing test/qunit/vendor/qunit.js...OK
Writing vendor/h5bp/css/main.css...OK
Writing vendor/h5bp/css/normalize.css...OK
Writing vendor/jam/backbone/backbone.js...OK
Writing vendor/jam/backbone/package.json...OK
Writing vendor/jam/backbone.layoutmanager/backbone.layoutmanager.js...OK
Writing vendor/jam/backbone.layoutmanager/package.json...OK
Writing vendor/jam/jquery/jquery.js...OK
Writing vendor/jam/jquery/package.json...OK
Writing vendor/jam/lodash/lodash.js...OK
Writing vendor/jam/lodash/lodash.min.js...OK
Writing vendor/jam/lodash/lodash.underscore.min.js...OK
Writing vendor/jam/lodash/package.json...OK
Writing vendor/jam/require.config.js...OK
Writing vendor/jam/require.js...OK
Writing vendor/js/libs/almond.js...OK
Writing vendor/js/libs/require.js...OK

Initialized from template "bbb".

Done, without errors.
```

Let's review what has been generated.

### index.html

This is a fairly standard stripped-down HTML5 Boilerplate foundation with the notable exception of including [RequireJS](http://requirejs.org) at the bottom of the page.

```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width,initial-scale=1">

  <title>Backbone Boilerplate</title>

  <!-- Application styles. -->
  <!--(if target dummy)><!-->
  <link rel="stylesheet" href="/app/styles/index.css">
  <!--<!(endif)-->
</head>
<body>
  <!-- Application container. -->
  <main role="main" id="main"></main>

  <!-- Application source. -->
  <!--(if target dummy)><!-->
  <script data-main="/app/config" src="/vendor/js/libs/require.js"></script>
  <!--<!(endif)-->

</body>
</html>
```

RequireJS - the [AMD](https://github.com/amdjs/amdjs-api/wiki/AMD) (Asynchronous Module Definition) module and script loader - will assist us with managing the modules in our application. We've already covered it in the last chapter, but let's recap what this particular block does in terms of the Boilerplate:

```
<script data-main="/app/config" src="/vendor/js/libs/require.js"></script>
```

The `data-main` attribute is used to inform RequireJS to load `app/config.js` (a configuration object) after it has finished loading itself. You'll notice that we've omitted the `.js` extension here as RequireJS can automatically add this for us, however it will respect your paths if we do choose to include it regardless. Let's now look at the config file being referenced.

### config.js

A RequireJS configuration object allows us to specify aliases and paths for dependencies we're likely to reference often (e.g., jQuery), bootstrap properties like our base application URL, and `shim` libraries that don't support AMD natively.

This is what the config file in Backbone Boilerplate looks like:

```javascript
// Set the require.js configuration for your application.
require.config({

  // Initialize the application with the main application file and the JamJS
  // generated configuration file.
  deps: ["../vendor/jam/require.config", "main"],

  paths: {
    // Put paths here.
  },

  shim: {
    // Put shims here.
  }

});
```

The first option defined in the above config is `deps: ["../vendor/jam/require.config", "main"]`. This informs RequireJS to load up additional RequireJS configuration as well a a main.js file, which is considered the entry point for our application.

 You may notice that we haven't specified any other path information for `main`. Require will infer the default `baseUrl` using the path from our `data-main` attribute in index.html. In other words, our `baseUrl` is `app/` and any scripts we require will be loaded relative to this location. We could use the `baseUrl` option to override this default if we wanted to use a different location.

The next block is `paths`, which we can use to specify paths relative to the `baseUrl` as well as the paths/aliases to dependencies we're likely to regularly reference.

After this comes `shim`, an important part of our RequireJS configuration which allows us to load libraries which are not AMD compliant. The basic idea here is that rather than requiring all libraries to implement support for AMD, the `shim` takes care of the hard work for us.

Going back to `deps`, the contents of our `require.config` file can be seen below. 

```javascript
var jam = {
    "packages": [
        {
            "name": "backbone",
            "location": "../vendor/jam/backbone",
            "main": "backbone.js"
        },
        {
            "name": "backbone.layoutmanager",
            "location": "../vendor/jam/backbone.layoutmanager",
            "main": "backbone.layoutmanager.js"
        },
        {
            "name": "jquery",
            "location": "../vendor/jam/jquery",
            "main": "jquery.js"
        },
        {
            "name": "lodash",
            "location": "../vendor/jam/lodash",
            "main": "./lodash.js"
        }
    ],
    "version": "0.2.11",
    "shim": {
        "backbone": {
            "deps": [
                "jquery",
                "lodash"
            ],
            "exports": "Backbone"
        },
        "backbone.layoutmanager": {
            "deps": [
                "jquery",
                "backbone",
                "lodash"
            ],
            "exports": "Backbone.LayoutManager"
        }
    }
};

```

The `jam` object is to support configuration of [Jam](http://jamjs.org/) - a package manager for the front-end which helps install, upgrade and configure the dependencies used by your project. It is currently the package manager of choice for Backbone Boilerplate.

Under the `packages` array, a number of dependencies are specified for inclusion, such as Backbone, the Backbone.LayoutManager plugin, jQuery and Lo-dash. 

For those curious about [Backbone.LayoutManager](https://github.com/tbranyen/backbone.layoutmanager), it's a Backbone plugin that provides a foundation for assembling layouts and views within Backbone.

Additional packages you install using Jam will have a corresponding entry added to `packages`.

### main.js

Next, we have `main.js`, which defines the entry point for our application. We use a global `require()` method to load an array containing any other scripts needed, such as our application `app.js` and our main router `router.js`. Note that most of the time, we will only use `require()` for bootstrapping an application and a similar method called `define()` for all other purposes.

The function defined after our array of dependencies is a callback which doesn't fire until these scripts have loaded. Notice how we're able to locally alias references to "app" and "router" as `app` and `Router` for convenience.

```javascript
require([
  // Application.
  "app",

  // Main Router.
  "router"
],

function(app, Router) {

  // Define your master router on the application namespace and trigger all
  // navigation from this instance.
  app.router = new Router();

  // Trigger the initial route and enable HTML5 History API support, set the
  // root folder to '/' by default.  Change in app.js.
  Backbone.history.start({ pushState: true, root: app.root });

  // All navigation that is relative should be passed through the navigate
  // method, to be processed by the router. If the link has a `data-bypass`
  // attribute, bypass the delegation completely.
  $(document).on("click", "a[href]:not([data-bypass])", function(evt) {
    // Get the absolute anchor href.
    var href = { prop: $(this).prop("href"), attr: $(this).attr("href") };
    // Get the absolute root.
    var root = location.protocol + "//" + location.host + app.root;

    // Ensure the root is part of the anchor href, meaning it's relative.
    if (href.prop.slice(0, root.length) === root) {
      // Stop the default event to ensure the link will not cause a page
      // refresh.
      evt.preventDefault();

      // `Backbone.history.navigate` is sufficient for all Routers and will
      // trigger the correct events. The Router's internal `navigate` method
      // calls this anyways.  The fragment is sliced from the root.
      Backbone.history.navigate(href.attr, true);
    }
  });

});

```

Inline, Backbone Boilerplate includes boilerplate code for initializing our router with HTML5 History API support and handling other navigation scenarios, so we don't have to.

### app.js

Let us now look at our `app.js` module. Typically, in non-Backbone Boilerplate applications, an `app.js` file may contain the core logic or module references needed to kick start an app.

In this case however, this file is used to define templating and layout configuration options as well as utilities for consuming layouts. To a beginner, this might look like a lot of code to comprehend, but the good news is that for basic apps, you're unlikely to need to heavily modify this. Instead, you'll be more concerned with modules for your app, which we'll look at next.

```javascript
define([
  "backbone.layoutmanager"
], function() {

  // Provide a global location to place configuration settings and module
  // creation.
  var app = {
    // The root path to run the application.
    root: "/"
  };

  // Localize or create a new JavaScript Template object.
  var JST = window.JST = window.JST || {};

  // Configure LayoutManager with Backbone Boilerplate defaults.
  Backbone.LayoutManager.configure({
    // Allow LayoutManager to augment Backbone.View.prototype.
    manage: true,

    prefix: "app/templates/",

    fetch: function(path) {
      // Concatenate the file extension.
      path = path + ".html";

      // If cached, use the compiled template.
      if (JST[path]) {
        return JST[path];
      }

      // Put fetch into `async-mode`.
      var done = this.async();

      // Seek out the template asynchronously.
      $.get(app.root + path, function(contents) {
        done(JST[path] = _.template(contents));
      });
    }
  });

  // Mix Backbone.Events, modules, and layout management into the app object.
  return _.extend(app, {
    // Create a custom object with a nested Views object.
    module: function(additionalProps) {
      return _.extend({ Views: {} }, additionalProps);
    },

    // Helper for using layouts.
    useLayout: function(name, options) {
      // Enable variable arity by allowing the first argument to be the options
      // object and omitting the name argument.
      if (_.isObject(name)) {
        options = name;
      }

      // Ensure options is an object.
      options = options || {};

      // If a name property was specified use that as the template.
      if (_.isString(name)) {
        options.template = name;
      }

      // Create a new Layout with options.
      var layout = new Backbone.Layout(_.extend({
        el: "#main"
      }, options));

      // Cache the reference.
      return this.layout = layout;
    }
  }, Backbone.Events);

});

```

Note: JST stands for JavaScript templates and generally refers to templates which have been (or will be) precompiled as part of a build step. When running `bbb release` or `bbb debug`, Underscore/Lo-dash templates will be precompiled to avoid the need to compile them at runtime within the browser.

### Creating Backbone Boilerplate Modules

Not to be confused with simply being just an AMD module, a Backbone Boilerplate `module` is a script composed of a:

* Model
* Collection
* Views (optional)

We can easily create a new Boilerplate module using `grunt-bbb` once again using `init`:

```shell
# Create a new module
$ bbb init:module

# Grunt prompt
Please answer the following:
[?] Module Name foo
[?] Do you need to make any changes to the above before continuing? (y/N) 

Writing app/modules/foo.js...OK
Writing app/styles/foo.styl...OK
Writing app/templates/foo.html...OK

Initialized from template "module".

Done, without errors.
```

This will generate a module `foo.js` as follows:

```javascript
// Foo module
define([
  // Application.
  "app"
],

// Map dependencies from above array.
function(app) {

  // Create a new module.
  var Foo = app.module();

  // Default Model.
  Foo.Model = Backbone.Model.extend({
  
  });

  // Default Collection.
  Foo.Collection = Backbone.Collection.extend({
    model: Foo.Model
  });

  // Default View.
  Foo.Views.Layout = Backbone.Layout.extend({
    template: "foo"
  });

  // Return the module for AMD compliance.
  return Foo;

});
```

Notice how boilerplate code for a model, collection and view have been scaffolded out for us.

Optionally, we may also wish to include references to plugins such as the Backbone LocalStorage or Offline adapters. One clean way of including a plugin in the above boilerplate could be:

```javascript
// Foo module
define([
  // Application.
  "app",
  // Plugins
  'plugins/backbone-localstorage'
],

// Map dependencies from above array.
function(app) {

  // Create a new module.
  var Foo = app.module();

  // Default Model.
  Foo.Model = Backbone.Model.extend({
    // Save all of the items under the `"foo"` namespace.
    localStorage: new Store('foo-backbone'),
  });

  // Default Collection.
  Foo.Collection = Backbone.Collection.extend({
    model: Foo.Model
  });

  // Default View.
  Foo.Views.Layout = Backbone.Layout.extend({
    template: "foo"
  });

  // Return the module for AMD compliance.
  return Foo;

});
```

### router.js

Finally, let's look at our application router which is used for handling navigation. The default router Backbone Boilerplate generates for us includes sane defaults out of the box and can be easily extended.

```javascript
define([
  // Application.
  "app"
],

function(app) {

  // Defining the application router, you can attach sub routers here.
  var Router = Backbone.Router.extend({
    routes: {
      "": "index"
    },

    index: function() {

    }
  });

  return Router;

});
```

If however we would like to execute some module-specific logic, when the page loads (i.e when a user hits the default route), we can pull in a module as a dependency and optionally use the Backbone LayoutManager to attach Views to our layout as follows:

```javascript
define([
  // Application.
  'app',

  // Modules
  'modules/foo'
],

function(app, Foo) {

  // Defining the application router, you can attach sub routers here.
  var Router = Backbone.Router.extend({
    routes: {
      '': 'index'
    },

    index: function() {
            // Create a new Collection
            var collection = new Foo.Collection();

            // Use and configure a 'main' layout
            app.useLayout('main').setViews({
                    // Attach the bar View into the content View
                    '.bar': new Foo.Views.Bar({
                            collection: collection
                    })
             }).render();
    }
  });

  // Fetch data (e.g., from localStorage)
  collection.fetch();

  return Router;

});
```

## Other Useful Tools & Projects

When working with Backbone, you usually need to write a number of different classes and files for your application. Scaffolding tools such as Grunt-BBB can help automate this process by generating basic boilerplates for the files you need for you.

### Yeoman

If you appreciated Grunt-BBB but would like to explore a tool for assisting with your broader development workflow, I'm happy to recommend a tool I've been helping with called [Yeoman](http://yeoman.io).

![](img/yeoman.png)

Yeoman is a workflow comprised of a collection of tools and best practices for helping you develop more efficiently. It's comprised of yo (a scaffolding tool), [Grunt](http://gruntjs.com)(a build tool) and [Bower](http://bower.io) (a client-side package manager). 

Where Grunt-BBB focuses on offering an opionated start for Backbone projects, Yeoman allows you to scaffold apps using Backbone (or other frameworks), get Backbone plugins directly from the command-line and compile your CoffeeScript, Sass or other abstractions without additional effort.

![](img/bower.png)

You may also be interested in [Brunch](http://brunch.io/), a similar project which uses skeleton boilerplates to generate new applications.

### Backbone DevTools

When building an application with Backbone, there's some additional tooling available for your day-to-day debugging workflow.

Backbone DevTools was created to help with this and is a Chrome DevTools extension allowing you to inspect events, syncs, View-DOM bindings and what objects have been instantiated. 

A useful View hierarchy is displayed in the Elements panel. Also, when you inspect a DOM element the closest View will be exposed via $view in the console.

![](img/bbdevtools.jpg)

At the time of writing, the project is currently available on [GitHub](https://github.com/spect88/backbone-devtools).

## Conclusions

In this section we reviewed Backbone Boilerplate and learned how to use the `bbb` tool to help us scaffold out our application.

If you would like to learn more about how this project helps structure your app, BBB includes some built-in boilerplate sample apps that can be easily generated for review.

These include a boilerplate tutorial project (`bbb init:tutorial`) and an implementation of my [TodoMVC](http://todomvc) project (`bbb init:todomvc`). I recommend checking these out as they'll provide you with a more complete picture of how Backbone Boilerplate, its templates, and so on fit into the overall setup for a web app.

For more about Grunt-BBB, remember to take a look at the official project [repository](https://github.com/backbone-boilerplate/grunt-bbb). There is also a related [slide-deck](https://dl.dropbox.com/u/79007/talks/Modern_Web_Applications/slides/index.html) available for those interested in reading more.





# Settings

### Mobile app development with jQuery Mobile

The mobile web is huge and it is continuing to grow at an impressive rate. Along with the massive growth of the mobile internet comes a striking diversity of devices and browsers. As a result, making your applications cross-platform and mobile-ready is both important and challenging.
Creating native apps is expensive.
It is very costly in terms of time and it usually requires varied experiences in programming languages like Objective C , C#, Java and JavaScript to support multiple runtime environments.

HTML, CSS, and JavaScript enable you to build a single application targeting a common runtime environment: the browser. This approach supports a broad range of mobile devices such as tablets, smartphones, and notebooks along with traditional PCs.

The challenging task is not only to adapt contents like text and pictures properly to various screen resolutions but also to have same user experience across native apps under different operating systems.
Like jQueryUI, jQuery Mobile is a user interface framework based on jQuery that works across all popular phone, tablet, e-Reader, and desktop platforms. It is built with accessibility and universal access in mind. 


The main idea of the framework is to enable anyone to create a mobile app using only HTML. Knowledge of a programming language is not required and there is no need to write complex, device specific CSS. For this reason jQMobile follows two main principles we first need to understand in order to integrate the framework to Backbone: *progressive enhancement* and *responsive web design*.


#### The Principle of progressive widget enhancement by jQMobile

JQuery Mobile follows progressive enhancement and responsive web design principles using HTML-5 markup-driven definitions and configurations.

A page in jQuery Mobile consists of an element with a `data-role="page"` attribute.
Within the `page` container, any valid HTML markup can be used, but for typical pages in jQM, the immediate children are divs with `data-role="header"`, `data-role="content"`, and `data-role="footer"`.
The baseline requirement for a page is only a page wrapper to support the navigation system, the rest is optional.

An initial HTML page looks like this:

```html
<!DOCTYPE html>
<html>
<head>
	<title>Page Title</title>

	<meta name="viewport" content="width=device-width, initial-scale=1">

	<link rel="stylesheet" href="http://code.jquery.com/mobile/1.3.0/jquery.mobile-1.3.0.min.css" />
	<script src="http://code.jquery.com/jquery-1.9.1.min.js"></script>
	<script src="http://code.jquery.com/mobile/1.3.0/jquery.mobile-1.3.0.min.js"></script>
</head>
<body>

<div data-role="page">
  <div data-role="header">
    <h1>Page Title</h1>
  </div>
  <div data-role="content">
     <p>Page content goes here.</p>
     <form>
       <label for="slider-1">Slider with tooltip:</label>
       <input type="range" name="slider-1" id="slider-1" min="0" max="100" value="50" 
        data-popup-enabled="true">
     </form>
  </div>
  <div data-role="footer">
     <h4>Page Footer</h4>
  </div>
</div>
</body>
</html>
```

*Example HTML setup of a basic jQuery Mobile page*

JQuery Mobile will transform the written HTML definition to the rendered HTML and CSS using its Progressive Widget Enhancement API. It also executes JavaScript which is conditioned by configurations, attribute properties, and runtime specific settings.

This implies: Whenever HTML content is added or changed, it needs to be handled by the progressive widget enhancement of jQuery Mobile.

![](img/chapter10-1-1-1.png)

*Comparison of the user interface of the default HTML to the jQuery Mobile enhanced version*

#### Understanding jQuery Mobile Navigation

The jQuery Mobile navigation system controls its application's lifecycle by automatically "hijacking" standard links and form submissions and turning them into AJAX requests. Whenever a link is clicked or a form is submitted, that event is automatically intercepted and used to issue an AJAX request based on the href or form action instead of reloading the page.

When the page document is requested, jQuery Mobile searches the document for all elements with the `data-role="page"` attribute, parses its contents, and inserts that code into the DOM of the original page.
Once the new page is prepared, jQuery Mobile's JavaScript triggers a transition that shows the new page and hides the HTML of the previous page in the DOM.

Next, any widgets in the incoming page are enhanced to apply all the styles and behavior. The rest of the incoming page is discarded so any scripts, stylesheets, or other information will not be included.

Via the *multi-page templating feature*, you can add as many pages as you want to the same HTML file within the body tag by defining divs with `data-role="page"` or `data-role="dialog"` attributes along with an `id` which can be used in links (preceded by a hashbang):


```html
<html>
  <head>...</head>
  <body>
  ...
  <div data-role="page" id="firstpage">
    ...
   <div data-role="content"> 
     <a href="#secondpage">go to secondpage</a>
   </div>
  </div>
  <div data-role="page" id="secondpage">
    ...
    <div data-role="content" >
       <a href="#firstdialog" data-rel="dialog" >open a page as a dialog</a>
    </div>
  </div>
  <div data-role="dialog" id="firstdialog">
    ...
     <div data-role="content">
       <a href="#firstpage">leave dialog and go to first page</a>
     </div>
  </div>
</body>
</html>
```

*jQuery Mobile multi-page templating example*

To, for example, navigate to *secondpage* and have it appear in a modal dialog using a fade-transition, you would just add the `data-rel="dialog"`, `data-transition="fade"`, and `href="index.html#secondpage"` attributes to an anchor tag.

Roughly speaking, having its own event cycle, jQuery Mobile is a tiny MVC framework which includes features like
progressive widget enhancement, pre-fetching, caching, and multi-page templating by HTML configurations innately. In general, a Backbone.js developer does not need to know about its internal event workflow, but will need to know how to apply HTML-based configurations which will take action within the event phase. The *Intercepting jQuery Mobile Events* section goes into detail regarding how to handle special scenarios when fine-grained JavaScript adaptions need to be applied.

For further introduction and explanations about jQuery Mobile visit:

* [http://view.jquerymobile.com/1.3.0/docs/intro/](http://view.jquerymobile.com/1.3.0/docs/intro/)
* [http://view.jquerymobile.com/1.3.0/docs/widgets/pages/](http://view.jquerymobile.com/1.3.0/docs/widgets/pages/)
* [http://view.jquerymobile.com/1.3.0/docs/intro/rwd.php](http://view.jquerymobile.com/1.3.0/docs/intro/rwd.php)

### Basic Backbone app setup for jQuery Mobile

The first major hurdle developers typically run into when building applications with jQuery Mobile and an MV* framework is that both frameworks want to handle application navigation.

To combine Backbone and jQuery Mobile, we first need to disable jQuery Mobile's navigation system and progressive enhancement. The second step will then be to make use of jQM's custom API to apply configurations and enhance components during Backbone's application lifecycle instead.

The mobile app example presented here is based on the existing codebase of the TodoMVC Backbone-Require.js example, which was discussed in an earlier chapter, and is enhanced to support jQuery Mobile.

![](img/chapter10-1-1.png)

*Screenshot of the TodoMVC app with jQuery Mobile*

This implementation makes use of Grunt-BBB as well as Handlebars.js. Additional utilities useful for mobile applications will be provided, which can be easily combined and extended.
(see the *Backbone Boilerplate & Grunt-BBB* and *Backbone Extensions* chapters) 

![](img/chapter10-1-2.png)

*Workspace of the TodoMVC app with jQueryMobile and Backbone*

The order of the files loaded by Require.js is as follows:

1. jQuery
2. Underscore/Lodash
3. handlebars.compiled
4. TodoRouter (instantiates specific views)
5. jQueryMobile
6. JqueryMobileCustomInitConfig
7. Instantiation of the Backbone Router

By opening the console in the project directory and then running the Grunt-Backbone command `grunt handlebars` or `grunt watch` in the console, it will combine and compile all template files to `dist/debug/handlebars_packaged`. To start the application, run `grunt server`.

Files instantiated, when redirected from the Backbone-Router are:

a) *BasicView.js* and *basic_page_simple.template*

   The BasicView is responsible for the Handlebars multipage-template processing. Its implementation of `render` calls the jQuery Mobile API `$.mobile.changePage` to handle page navigation and progressive widget enhancement.
   
b) Concrete view with its template partial

   E.g., `EditTodoPage.js` and `editTodoView.template_partial`


The head section of `index.html` needs to load the `jquerymobile.css` as well as the `base.css`,
which is used by all Todo-MVC apps, and the `index.css` for some project-specific custom CSS.

```html
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1">

    <title>TodoMVC Jquery Mobile</title>

<!-- widget and responsive design styles -->
    <link rel="stylesheet" href="/assets/css/jquerymobile.css">
<!-- used by all TodoMVC apps -->
    <link rel="stylesheet" href="/assets/css/base.css">
<!-- custom css -->
    <link rel="stylesheet" href="/assets/css/index.css">
</head>

<body>
    <script data-main="/app/config" src="/assets/js/libs/require.js"></script>
</body>
</html>
```

*index.html*

### Workflow with Backbone and jQueryMobile

By delegating the routing and navigation functions of the jQuery Mobile Framework to Backbone, we can profit from its clear separation of application structure to later on easily share application logic between a desktop webpage, tablets, and mobile apps.

We now need to contend with the different ways in which Backbone and jQuery Mobile handle requests. `Backbone.Router` offers an explicit way to define custom navigation routes, while jQuery Mobile uses URL hash fragments to reference separate pages or views in the same document.

Some of the ideas that have been previously proposed to work-around this problem included manually patching Backbone and jQuery Mobile. The solution demonstrated below will not only simplify the handling of the jQuery Mobile component initialization event-cycle, but also enables use of existing Backbone Router handlers.

To adapt the navigation control from jQuery Mobile to Backbone, we first need to apply some specific settings to the `mobileinit` event which occurs after the framework has loaded in order to let the Backbone Router decide which page to load.

A configuration which will get jQM to delegate navigation to Backbone and which will also enable manual widget creation triggering is given below:

```javascript
$(document).bind("mobileinit", function(){

// Disable jQM routing and component creation events   
   // disable hash-routing
   $.mobile.hashListeningEnabled = false;
   // disable anchor-control
   $.mobile.linkBindingEnabled = false;
   // can cause calling object creation twice and back button issues are solved
   $.mobile.ajaxEnabled = false;
   // Otherwise after mobileinit, it tries to load a landing page
   $.mobile.autoInitializePage = false;
   // we want to handle caching and cleaning the DOM ourselves
   $.mobile.page.prototype.options.domCache = false;

// consider due to compatibility issues
   // not supported by all browsers
   $.mobile.pushStateEnabled = false;
   // Solves phonegap issues with the back-button
   $.mobile.phonegapNavigationEnabled = true;
   //no native datepicker will conflict with the jQM component
   $.mobile.page.prototype.options.degradeInputs.date = true;
});
```

*jquerymobile.config.js*

The behaviour and usage of the new workflow will be explained below, grouped by its functionalities:

a) Routing to a concrete View-page

b) Management of mobile page templates

c) DOM management

d) $.mobile.changePage


In the following discussion, the steps 1-11 in the text refer to the new workflow diagram of the mobile application below.

![](img/chapter10-2-1.png)

*Workflow of TodoMVC, with Backbone and jQueryMobile*

####Routing to a concrete View page, Inheriting from BasicView

When the hash URL changes, e.g., a link is clicked, the configuration above prevents jQM from triggering its events. Instead, the Backbone Router listens to the hash changes and decides which view to request.

Experience has shown that, for mobile pages, it is a good practice to create basic prototypes for jQM components such as basic pages, popups, and dialogs, as well as for using the jQuery Validation Plugin. This makes it much easier to exchange device-specific view logic at runtime and adopt general strategies. This will also help to add syntax and to support multi-chaining of prototype inheritance with JavaScript and Backbone.

By creating a `BasicView` superclass, we enable all inheriting view-pages to share a common way of handling jQM along with common usage of a template engine and specific view handling.

When building with Grunt/Yeoman, the semantic templates are compiled by Handlebar.js and the AMDs template files are combined into a single file. By merging all page definitions into a single-file-app, it becomes offline capable, which is important for mobile app.


#### Management of Mobile Page Templates

Within a concrete View page, you can override properties for static values and functions to return dynamic values of the super class `BasicView`. These values will be processed later by the BasicView to construct the HTML of a jQuery Mobile page with the help of Handlebars.

Additional dynamic template parameters, e.g., Backbone model information, will be taken from the specific View and merged with the ones from the BasicView.

A concrete View might look like:

```javascript
define([
    "backbone", "modules/view/abstract/BasicView"],
    function (Backbone, BasicView) {
        return BasicView.extend({
            id : "editTodoView", 
            getHeaderTitle : function () {
                return "Edit Todo";
            },
            getSpecificTemplateValues : function () {
                return this.model.toJSON();
            },
            events : function () {
                // merged events of BasicView, to add an older fix for back button functionality
                return _.extend({
                    'click #saveDescription' : 'saveDescription'
                }, this.constructor.__super__.events);
            },
            saveDescription : function (clickEvent) {
                this.model.save({
                    title : $("#todoDescription", this.el).val()
                });
                return true;
            }
        });
    });
```

*A concrete View (EditTodoPage.js)*


By default, the BasicView uses `basic_page_simple.template` as the Handlebars template. If you need to use a custom template or want to introduce a new Super abstract View with an alternate template, override the `getTemplateID` function:

```javascript
getTemplateID : function(){
  return "custom_page_template";
}
```

By convention, the `id` attribute will be taken as the id of the jQM page as well as the filename of the corresponding template file to be inserted as a partial in the `basic_page_simple` template. In the case of the `EditTodoPage` view, the name of the file will be `editTodoPage.template_partial`.

Every concrete page is meant to be a partial, which will be inserted in the `data-role="content"` element,
where the parameter `templatePartialPageID` is located.

Later on, the result of the `getHeaderTitle` function from `EditTodoPage` will replace the *headerTitle* in the abstract template.


```javascript
<div data-role="header">
        {{whatis "Specific loaded Handlebars parameters:"}}
        {{whatis this}}
        <h2>{{headerTitle}}</h2>
        <a id="backButton" href="href="javascript:history.go(-1);" data-icon="star" data-rel="back" >back</a>
    </div>
    <div data-role="content">
        {{whatis "Template page trying to load:"}}
        {{whatis templatePartialPageID}}
        {{> templatePartialPageID}}
    </div>
    <div data-role="footer">
        {{footerContent}}
</div>
```

*basic_page_simple.template*


*Note: The `whatis` Handlebars View helper does simple logging of parameters.*


All the additional parameters being returned by `getSpecificTemplateValues` will be inserted into the concrete template `editTodoPage.template_partial`.

Because `footerContent` is expected to be used rarely, its content is returned by `getSpecificTemplateValues`.

In the case of the EditTodoPage view, all the model information is being returned and `title` is used in the concrete partial page:


```html
<div data-role="fieldcontain">
    <label for="todoDescription">Todo Description</label>
    <input type="text" name="todoDescription" id="todoDescription" value="{{title}}" />
</div>
    <a id="saveDescription" href="#" data-role="button" data-mini="true">Save</a>
```

*editTodoView.template_partial*


When `render` is triggered, the `basic_page_simple.template` and `editTodoView.template_partial` templates will be loaded and the parameters from `EditTodoPage` and `BasicView` will be combined and generated by Handlebars to generate:

```html
    <div data-role="header">
        <h2>Edit Todo</h2>
        <a id="backButton" href="href="javascript:history.go(-1);" data-icon="star" data-rel="back" >back</a>
    </div>
    <div data-role="content">
      <div data-role="fieldcontain">
       <label for="todoDescription">Todo Description</label>
       <input type="text" name="todoDescription" id="todoDescription" value="Cooking" />
      </div>
      <a id="saveDescription" href="#" data-role="button" data-mini="true">Save</a>
    </div>
    <div data-role="footer">
        Footer
    </div>
```

*Final HTML definition resulting from basic_page_simple_template and editTodoView.template_partial*

The next section explains how the template parameters are collected by the `BasicView` and the HTML definition is loaded.


#### DOM management and $.mobile.changePage

When `render` is executed (line 29 is the source code listing below), `BasicView` first cleans up the DOM by removing the previous page (line 70). To delete the elements from the DOM, `$.remove` cannot be used, but `$previousEl.detach()` can be since `detach` does not remove the element's attached events and data.

This is important, because jQuery Mobile still needs information (e.g., to trigger transition effects when switching to another page). Keep in mind that the DOM data and events should be cleared later on as well to avoid possible performance issues.

Other strategies than the one used in the function `cleanupPossiblePageDuplicationInDOM` to cleanup the DOM are viable. To only remove the old page having the same id as the current from the DOM, when it was already requested before, would also be a working strategy of preventing DOM duplication. Depending on what fits best to your application needs, it is also possibly a one-banana problem to exchange it using a caching mechanism.

Next, `BasicView` collects all template parameters from the concrete View implementation and inserts the HTML of the requested page into the body. This is done in steps 4, 5, 6, and 7 in the diagram above (between lines 23 and 51 in the source listing).

Additionally, the `data-role` will be set on the jQuery Mobile page. Commonly used attribute values are
page, dialog, or popup.

As you can see, (starting at line 74), the `goBackInHistory` function contains a manual implementation to handle the back button's action. In certain scenarios, the back button navigation functionality of jQuery Mobile was not working with older versions and disabled jQMobile's navigation system.


```javascript
 1 define([
 2     "lodash",
 3     "backbone",
 4     "handlebars",
 5     "handlebars_helpers"
 6 ],
 7 
 8 function (_, Backbone, Handlebars) {
 9     var BasicView = Backbone.View.extend({
10         initialize: function () {
11             _.bindAll();
12             this.render();
13         },
14         events: {
15             "click #backButton": "goBackInHistory"
16         },
17         role: "page",
18         attributes: function () {
19             return {
20                 "data-role": this.role
21             };
22         },
23         getHeaderTitle: function () {
24             return this.getSpecificTemplateValues().headerTitle;
25         },
26         getTemplateID: function () {
27             return "basic_page_simple";
28         },
29         render: function () {
30             this.cleanupPossiblePageDuplicationInDOM();
31             $(this.el).html(this.getBasicPageTemplateResult());
32             this.addPageToDOMAndRenderJQM();
33             this.enhanceJQMComponentsAPI();
34         },
35 // Generate HTML using the Handlebars templates
36         getTemplateResult: function (templateDefinitionID, templateValues) {
37             return window.JST[templateDefinitionID](templateValues);
38         },
39 // Collect all template paramters and merge them
40         getBasicPageTemplateResult: function () {
41             var templateValues = {
42                 templatePartialPageID: this.id,
43                 headerTitle: this.getHeaderTitle()
44             };
45             var specific = this.getSpecificTemplateValues();
46             $.extend(templateValues, this.getSpecificTemplateValues());
47             return this.getTemplateResult(this.getTemplateID(), templateValues);
48         },
49         getRequestedPageTemplateResult: function () {
50             this.getBasicPageTemplateResult();
51         },
52         enhanceJQMComponentsAPI: function () {
53 // changePage
54             $.mobile.changePage("#" + this.id, {
55                 changeHash: false,
56                 role: this.role
57             });
58         },
59 // Add page to DOM
60         addPageToDOMAndRenderJQM: function () {
61             $("body").append($(this.el));
62             $("#" + this.id).page();
63         },
64 // Cleanup DOM strategy
65         cleanupPossiblePageDuplicationInDOM: function () {
66         // Can also be moved to the event "pagehide": or "onPageHide"
67             var $previousEl = $("#" + this.id);
68             var alreadyInDom = $previousEl.length >= 0;
69             if (alreadyInDom) {
70                 $previousEl.detach();
71             }
72         },
73 // Strategy to always support back button with disabled navigation
74         goBackInHistory: function (clickEvent) {
75             history.go(-1);
76             return false;
77         }
78     });
79 
80     return BasicView;
81 });
```

*BasicView.js*

After the dynamic HTML is added to the DOM, `$.mobile.changePage` has to be applied at step 8 (code line 54).

This is the most important API call, because it triggers the jQuery Mobile component creation for the current page.

Next, the page will be displayed to the user at step 9.


```javascript
<a data-mini="true" data-role="button" href="#" id="saveDescription" data-corners="true" 
data-shadow="true" data-iconshadow="true" data-wrapperels="span" data-theme="c" 
class="ui-btn ui-shadow ui-btn-corner-all ui-mini ui-btn-up-c">
    <span class="ui-btn-inner">
         <span class="ui-btn-text">Save</span>
     </span>
</a>
```

![](img/chapter10-2-2.png)

*Look and feel of the written HTML code and the jQuery Mobile enhanced Todo description page*

UI enhancement is done in the `enhanceJQMComponentsAPI` function in line 52:

```javascript
$.mobile.changePage("#" + this.id, {
                      changeHash: false,
                      role: this.role
                    });
```

To retain control of hash routing, `changeHash` has to be set to false and the proper `role` parameter provided to guarantee proper page appearance. Finally, `changePage` will show the new page with its defined transition to the user.

For the basic use cases, it is advised to have one View per page, and always render the complete page again by calling `$.mobile.changePage` when widget enhancement needs to be done.

To progress component enrichment of a newly added HTML-fragment into the DOM, advanced techniques need to be applied to guarantee correct appearance of the mobile components. You need to be very careful when creating partial HTML code and updating values on UI elements. The next section will explain how to handle these situations.


### Applying advanced jQM techniques to Backbone

#### Dynamic DOM Scripting

The solution described above solves the issues of handling routing with Backbone by calling `$.mobile.changePage('pageID')`.  Additionally, it guarantees that the HTML page will be completely enhanced by the markup for jQuery Mobile.

The second tricky part with jQuery Mobile is to dynamically manipulate specific DOM contents (e.g. after loading in content with Ajax). We suggest you use this technique only if there is evidence for an appreciable performance gain.

With the current version (1.3), jQM provides three ways, documented and explained below in the official API, on forums, and blogs.

* **$(“pageId”).trigger(“pagecreate”)**

    *Creates markup of header, content as well as footer*

* **$(“anyElement”).trigger(“create”)**

    *Creates markup of the element as well as all children*

* **$(“myListElement”).listview(“refresh”)**
* **$('[type="radio"]').checkboxradio()**
* **$('[type="text"]').textinput()**
* **$('[type="button"]').button()**
* **$('[data-role="navbar"]').navbar()**
* **$('[type="range"]').slider()**
* **$('select').selectmenu()**

    *Every component of jQM offers plugins methods they can invoke to update the state of specific UI elements.*


Sometimes, when creating a component from scratch, the following error can occur: 'cannot call methods on listview prior to initialization'. This can be avoided, with component initialization prior to markup enhancement, by calling it in the following way:

```javascript
 $('#mylist').listview().listview('refresh')
```

To see more details and enhancements for further scripting pages of JQM read their API and follow the release notes frequently.

* [jQuery Mobile: Page Scripting](http://jquerymobile.com/test/docs/pages/page-scripting.html)
* [jQuery Mobile: Document Ready vs. Page Events](http://stackoverflow.com/questions/14468659/jquery-mobile-document-ready-vs-page-events/ )
* [StackOverflow: Markup Enhancement of Dynamically Added Content](http://stackoverflow.com/questions/14550396/jquery-mobile-markup-enhancement-of-dynamically-added-content)


If you consider using a `Model-Binding Plugin`, you will need to come up with an automated mechanism to enrich single components.

After having a look at the previous section about Dynamic DOM Scripting, it might not be acceptable to completely re-create a component (e.g a Listview) which takes a longer time to load and to reduce the complexity of event-delegation. Instead, the component-specific plugins, which will only update the needed parts of the HTML and CSS, should be used.

In the case of a Listview, you would need to call the following function to update the list of added, edited, or removed entries:

```javascript
$('#mylist').listview()
```

You need to come up with a means of detecting the component type to in order to decide which plugin method needs to be called. The jQuery Mobile Angular.js Adapter provides such a strategy and solution as well.

[Example of Model Binding with jQuery Mobile](https://github.com/tigbro/jquery-mobile-angular-adapter/blob/master/src/main/webapp/integration/jqmWidgetPatches.js)


#### Intercepting jQuery Mobile Events

In special situations you will need to take action on a triggered jQuery Mobile event, which can be done as follows:

```javascript
$('#myPage').live('pagebeforecreate', function(event){
         console.log(page was inserted into the DOM');
   	//run your own enhancement scripting here...
          // prevent the page plugin from making its manipulations
  	return false;
});

$('#myPage').live('pagecreate', function(event){
          console.log(‘page was enhanced by jQM');
});
```

In such scenarios, it is important to know when the jQuery Mobile events occur. The following diagram  depicts the event cycle (page A is the outgoing page and page B is the incoming page).


![](img/chapter10-3-1.png)

*jQuery Mobile Event Cycle*

An alternative is the jQuery Mobile Router project, which you might use to replace the Backbone Router. With the help of the jQM Router project, you could achieve a powerful way to intercept and route one of the various jQM events. It is an extension to jQuery Mobile, which can be used independently.

Be aware that jQM-Router misses some features of Backbone.Router and is tightly coupled with the jQuery Mobile framework. For these reasons, we did not use it for the TodoMVC app. If you intend to use it, consider using a Backbone.js custom build to exclude the router code. This might save around 25% relative to the max compressed size of 17,1 KB.

[Backbone's Custom Builder](http://gregfranko.com/backbone/customBuild/)


#### Performance

Performance is an important topic on mobile devices. jQuery Mobile provides various tools that create performance logs which can give you a good overview of the actual time spent in routing logic, component enhancement, and visual effects.

Depending on the device, the time spent on transitions can take up to 90% of the load time. To disable all transitions, you can either pass the transition `none` to `$.mobile.changePage()`, in the configuration code block:

```javascript
$(document).bind("mobileinit", function(){
…
// Otherwise, depending on takes up to 90% of loadtime
  $.mobile.defaultPageTransition = "none";
  $.mobile.defaultDialogTransition = "none";
    });
  })
```

or consider adding device-specific settings, for example: 

```javascript
$(document).bind("mobileinit", function(){

  var iosDevice =((navigator.userAgent.match(/iPhone/i))
  || (navigator.userAgent.match(/iPod/i))) ? true : false;

  $.extend(  $.mobile , {
    slideText :  (iosDevice) ? "slide" : "none",
    slideUpText :  (iosDevice) ? "slideup" : "none",
    defaultPageTransition:(iosDevice) ? "slide" : "none",
    defaultDialogTransition:(iosDevice) ? "slide" : "none"
  });
```

Also, consider doing your own pre-caching of enhanced jQuery Mobile pages.

The jQuery Mobile API is frequently enhanced with regards to this topic in each new release. We suggest you take a look at the latest updated API to determine an optimal caching strategy with dynamic scripting that best fits your needs.

For further information on performance, see the following:

* [jQuery Mobile Profiling Tools](https://github.com/jquery/jquery-mobile/tree/master/tools)
* [Device specific jQuery Mobile configuations](http://backbonefu.com/2012/01/jquery-mobile-and-backbone-js-the-ugly/)
* [jQuery Mobile Debugging tools](http://www.objectpartners.com/2012/11/02/use-jquery-mobile%E2%80%99s-tools-suite-to-help-you-debug-and-improve-your-jquery-mobile-application/)
* [jQuery Mobile precaching functionalities](http://jquerymobile.com/demos/1.2.0/docs/pages/page-cache.html)


#### Clever Multi-Platform Support Management

Nowadays, a company typically has an existing webpage and management decides to provide an additional mobile app to customers. The code of the web page and the mobile app become independent of each other and the time required for content or feature changes becomes much higher than for the webpage alone.

As the trend is towards an increasing number of mobile platforms and dimensions, the effort required to support them is only increasing as well. Ultimately, creating per-device experiences is not always viable. However, it is essential that content is available to all users, regardless of their browser and platform. This principle must be kept in mind during the design phase.

*[Responsive Design](http://www.lukew.com/ff/entry.asp?933)* and *[Mobile First](http://www.abookapart.com/products/mobile-first)* approaches address these challenges.

The mobile app architecture presented in this chapter takes care of a lot of the actual heavy lifting required, as it supports responsive layouts out of the box and even supports browsers which cannot handle media queries. It might not be obvious that jQM is a UI framework not dissimilar to jQuery UI. jQuery Mobile is using the widget factory and is capable of being used for more than just mobile environments.

To support multi-platform browsers using jQuery Mobile and Backbone,
you can, in order of increasing time  and effort:

1. Ideally, have one code project, where only CSS differs for different devices.
2. Same code project, and at runtime different HTML templates
   and super-classes are exchanged per device type.
3. Same code project, and the Responsive Design API and most widgets of jQuery Mobile will be reused.
   For the desktop browser, some components will be added by another widget framework
   (e.g. *jQueryUI* or *Twitter Boostrap*), e.g. controlled by the HTML templating.
4. Same code project, and at runtime, jQuery Mobile will be completely replaced 
   by another widget framework (e.g. *jQueryUI* or *Twitter Boostrap*).
   Super-classes and configurations, as well as concrete Backbone.View code snippets need to be replaced.
5. Different code projects, but common modules are reused.
6. For the desktop app, there is a completely separate code project.
   Reasons might be the usage of complete different programming languagages
   and/or frameworks, lack of Responsive Design knowledge or legacy of pollution.

The ideal solution, to build a nice-looking desktop application with only one mobile framework, sounds crazy, but is feasible.

If you have a look at the jQuery Mobile API page in a desktop browser, it does not look anything like a mobile application.

![](img/chapter10-3-3.png)

*Desktop view of the jQuery Mobile API and Docs application (http://view.jquerymobile.com/1.3.0/)*

The same goes for the jQuery Mobile design examples, where jQuery Mobile intends to add further user interface experiences.

![](img/chapter10-3-4.png)

*Design examples of jQuery Mobile for desktop environments, http://jquerymobile.com/designs/#desktop*

The accordions, date-pickers, sliders - everything in the desktop UI is re-using what jQM would be providing users on mobile devices. By way of example, adding the attribute `data-mini="true"` on components will lose the clumsiness of the mobile widgets on a desktop browser.

See http://jquerymobile.com/demos/1.2.0/docs/forms/forms-all-mini.html, Mini-widgets for desktop applications by jQuery Mobile.

Thanks to some media queries, the desktop UI can make optimal use of whitespace, expanding component blocks out and providing alternative layouts while still making use of jQM as the component framework.

The benefit of this is that you don’t need to pull in another widget framework (e.g., jQuery UI) separately to be able to take advantage of these features. Thanks to the ThemeRoller, the components can look pretty much exactly how you would like them to and users of the app can get a jQM UI for lower-resolutions and a jQM-ish UI for everything else.

The take away here is just to remember that if you are not already going through the hassle of conditional script/style loading based on screen-resolution (using matchMedia.js, etc.), there are simpler approaches that can be taken to cross-device component theming. At least the Responsive Design API of jQuery Mobile, which was added since version 1.3.0, is always reasonable because it will work for mobile as well as for desktop. In summary, you can manage jQuery Mobile components to give users a typical desktop appearance and they will not realize a difference.

[Responsive Design with jQuery Mobile](http://view.jquerymobile.com/1.3.0/docs/intro/rwd.php)

Also, if you hit your limits of CSS-styling and configurations of your jQuery Mobile application for desktop browsers, the additional effort to use jQuery Mobile and Twitter Bootstrap together can be quite simple.
In the case that a desktop browser requests the page and Twitter Bootstrap has been loaded, the mobile TodoMVC app would need conditional code to not trigger the  jQM Widget processive enhancement plugins API (demonstrated in the  *Dynamic DOM Scripting* section) in the Backbone.View implementation. Therefore, as explained in the previous sections, we recommend triggering widget enhancements by `$.mobile.changePage` only once to load the complete page.

An example of such a widget hybrid usage can be seen here:

![](img/chapter10-3-2.png)

*[Appengine boilerplate, desktop and mobile appearance](http://appengine.beecoss.com)*

Although it is using server-side technologies for templating using the programming language Python,
the principle of triggering progressive enhancement at page load is the same as `$mobile.changePage`.

As you can see, the JavaScript and even the CSS stays the same. The only device-specific conditions and differences in implementations are for selecting the appropriate framework imports, which are located in the HTML template:

```html
...
 {% if is_mobile %}
    <link rel="stylesheet" href="/mobile/jquery.mobile-1.1.0.min.css" />
    {% else %}
      <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
      <link rel="stylesheet" href="/css/style.css" />
      <link rel="stylesheet" href="/css/bootstrap.min.css">
      <link rel="stylesheet" href="/css/bootstrap-responsive.min.css">
    {% endif %}
      <link rel="stylesheet" href="/css/main.css" />

    {% block mediaCSS %}{% endblock %}
...
 {% if is_mobile %}
      <script src="/mobile/jquery.mobile-1.1.0.min.js"></script>
    {% else %}
      <script src="/js/libs/bootstrap.min.js"></script>
    {% endif %}
...
```

# Resources

## Books &amp; Courses

* [PeepCode: Backbone.js Basics](https://peepcode.com/products/backbone-js)
* [CodeSchool: Anatomy Of Backbone](http://www.codeschool.com/courses/anatomy-of-backbonejs)
* [Recipes With Backbone](http://recipeswithbackbone.com/)
* [Backbone Patterns](http://ricostacruz.com/backbone-patterns/)
* [Backbone On Rails](https://learn.thoughtbot.com/products/1-backbone-js-on-rails)
* [MVC In JavaScript With Backbone](https://github.com/Integralist/Blog-Posts/blob/master/2012-08-16-MVC-in-JavaScript-with-Backbone.md)
* [Backbone Tutorials](http://backbonetutorials.com/)
* [Derick Bailey's Resources For Learning Backbone](http://lostechies.com/derickbailey/2011/09/13/resources-for-and-how-i-learned-backbone-js/)

## Extensions/Libraries

* [MarionetteJS](http://marionettejs.com/)
* [AuraJS](https://github.com/aurajs/aura)
* [Thorax](http://thoraxjs.org)
* [Lumbar](http://walmartlabs.github.com/lumbar)
* [Backbone Layout Manager](https://github.com/tbranyen/backbone.layoutmanager)
* [Backbone Boilerplate](https://github.com/backbone-boilerplate/backbone-boilerplate)
* [Backbone.ModelBinder](https://github.com/theironcook/Backbone.ModelBinder)
* [Backbone Relational - for model relationships](https://github.com/PaulUithol/Backbone-relational)
* [Backbone CouchDB](https://github.com/janmonschke/backbone-couchdb)
* [Backbone Validations - HTML5 inspired validations](https://github.com/n-time/backbone.validations)

# Conclusions

I hope that you've found this introduction to Backbone.js of value. What you've hopefully learned is that while building a JavaScript-heavy application using nothing more than a DOM manipulation library (such as jQuery) is certainly a possible feat, it is difficult to build anything non-trivial without any formal structure in place. Your nested pile of jQuery callbacks and DOM elements are unlikely to scale and they can be very difficult to maintain as your application grows.

The beauty of Backbone.js is its simplicity. It's very small given the functionality and flexibility it provides, which is evident if you begin to study the Backbone.js source. In the words of Jeremy Ashkenas, "The essential premise at the heart of Backbone has always been to try and discover the minimal set of data-structuring (Models and Collections) and user interface (Views and URLs) primitives that are useful when building web applications with JavaScript." It just helps you improve the structure of your applications, helping you better separate concerns. There isn't anything more to it than that.

Backbone offers Models with key-value bindings and events, Collections with an API of rich enumerable methods, declarative Views with event handling and a simple way to connect an existing API to your client-side application over a RESTful JSON interface. Use it and you can abstract away data into sane models and your DOM manipulation into views, binding them together using nothing more than events.

Almost any developer working on JavaScript applications for a while will ultimately create a similar solution on their own if they value architecture and maintainability. The alternative to using it or something similar is rolling your own - often a process that involves glueing together a diverse set of libraries that weren't built to work together. You might use jQuery BBQ for history management and Handlebars for templating, while writing abstracts for organizing and testing code by yourself. 

Contrast this with Backbone, which has [literate](http://en.wikipedia.org/wiki/Literate_programming) [documentation](http://backbonejs.org/docs/backbone.html) of the source code, a thriving community of both users and hackers, and a large number of questions about it asked and answered daily on sites like [Stack Overflow](http://stackoverflow.com/search?q=backbone). Rather than re-inventing the wheel there are many advantages to structuring your application using a solution based on the collective knowledge and experience of an entire community. 

In addition to helping provide sane structure to your applications, Backbone is highly extensible supporting more custom architecture should you require more than what is prescribed out of the box. This is evident by the number of extensions and plugins which have been released for it over the past year, including those which we have touched upon such as MarionetteJS and Thorax. 

These days Backbone.js powers many complex web applications, ranging from the LinkedIn [mobile app](http://touch.www.linkedin.com/mobile.html) to popular RSS readers such as [NewsBlur](http://newsblur.com) through to social commentary widgets such as [Disqus](http://disqus.com/). This small library of simple, but sane abstractions has helped to create a new generation of rich web applications, and I and my collaborators hope that in time it can help you too. 

If you're wondering whether it is worth using Backbone on a project, ask yourself whether what you are building is complex enough to merit using it. Are you hitting the limits of your ability to organize your code? Will your application have regular changes to what is displayed in the UI without a trip back to the server for new pages? Would you benefit from a separation of concerns? If so, a solution like Backbone may be able to help.

Google's GMail is often cited as an example of a well built single-page app. If you've used it, you might have noticed that it requests a large initial chunk, representing most of the JavaScript, CSS and HTML most users will need and everything extra needed after that occurs in the background. GMail can easily switch between your inbox to your spam folder without needing the whole page to be re-rendered. Libraries like Backbone make it easier for web developers to create experiences like this.

That said, Backbone won't be able to help if you're planning on building something which isn't worth the learning curve associated with a library. If your application or site will still be using the server to do the heavy lifting of constructing and serving complete pages to the browser, you may find just using plain JavaScript or jQuery for simple effects or interactions to be more appropriate. Spend time assessing how suitable Backbone might be for you and make the right choice on a per-project basis.

Backbone is neither difficult to learn nor use, however the time and effort you spend learning how to structure applications using it will be well worth it. While reading this book will equip you with the fundamentals needed to understand the library, the best way to learn is to try building your own real-world applications. You will hopefully find that the end product is cleaner, better organized and more maintainable code.

With that, I wish you the very best with your onward journey into the world of Backbone and will leave you with a quote from American writer [Henry Miller](http://en.wikipedia.org/wiki/Henry_Miller) -  “One’s destination is never a place, but a new way of seeing things.” 

# Appendix

## A Simple JavaScript MVC Implementation

A comprehensive discussion of Backbone's implementation is beyond the scope of this book. We can, however, present a simple MVC library - which we will call Cranium.js - that illustrates how frameworks such as Backbone implement the MVC pattern. 

Like Backbone, we will rely on [Underscore](http://underscorejs.org "Underscore.js") for inheritance and templating.

### Event System

At the heart of our JavaScript MVC implementation is an `Event` system (object) based on the Publisher-Subscriber Pattern which makes it possible for MVC components to communicate in an elegant, decoupled manner. Subscribers 'listen' for specific events of interest and react when Publishers broadcast these events.

`Event` is mixed into both the View and Model components so that instances of either of these components can publish events of interest.

```javascript
// cranium.js - Cranium.Events

var Cranium = Cranium || {};

// Set DOM selection utility
var $ = document.querySelector.bind(document) || this.jQuery || this.Zepto;

// Mix in to any object in order to provide it with custom events.
var Events = Cranium.Events = {
  // Keeps list of events and associated listeners
  channels: {},

  // Counter
  eventNumber: 0,

  // Announce events and passes data to the listeners;
  trigger: function (events, data) {
    for (var topic in Cranium.Events.channels){
      if (Cranium.Events.channels.hasOwnProperty(topic)) {
        if (topic.split("-")[0] == events){
          Cranium.Events.channels[topic](data) !== false || delete Cranium.Events.channels[topic];
        }
      }
    }
  },
  // Registers an event type and its listener
  on: function (events, callback) {
    Cranium.Events.channels[events + --Cranium.Events.eventNumber] = callback;
  },
  // Unregisters an event type and its listener
  off: function(topic) {
    delete Cranium.Events.channels[topic];
  }            
};
```

The Event system makes it possible for:

* a View to notify its subscribers of user interaction (e.g., clicks or input in a form), to update/re-render its presentation, etc.
* a Model whose data has changed to notify its Subscribers to update themselves (e.g., view to re-render to show accurate/updated data), etc.

### Models

Models manage the (domain-specific) data for an application. They are concerned with neither the user-interface nor presentation layers, but instead represent structured data that an application may require. When a model changes (e.g when it is updated), it will typically notify its observers (Subscribers) that a change has occurred so that they may react accordingly.

Let's see a simple implementation of the Model:

```javascript
// cranium.js - Cranium.Model

// Attributes represents data, model's properties.
// These are to be passed at Model instantiation.
// Also we are creating id for each Model instance 
// so that it can identify itself (e.g. on chage 
// announcements)
var Model = Cranium.Model = function (attributes) {
    this.id = _.uniqueId('model');
    this.attributes = attributes || {};
};

// Getter (accessor) method;
// returns named data item
Cranium.Model.prototype.get = function(attrName) {
    return this.attributes[attrName];
};

// Setter (mutator) method;
// Set/mix in into model mapped data (e.g.{name: "John"})
// and publishes the change event
Cranium.Model.prototype.set = function(attrs){
    if (_.isObject(attrs)) {
      _.extend(this.attributes, attrs);
      this.change(this.attributes);
    }
    return this;
};

// Returns clone of the Models data object 
// (used for view template rendering)
Cranium.Model.prototype.toJSON = function(options) {
    return _.clone(this.attributes);
};

// Helper function that announces changes to the Model
// and passes the new data
Cranium.Model.prototype.change = function(attrs){
    this.trigger(this.id + 'update', attrs);
}; 

// Mix in Event system
_.extend(Cranium.Model.prototype, Cranium.Events);
```

### Views

Views are a visual representation of models that present a filtered view of their current state. A view typically observes a model and is notified when the model changes, allowing the view to update itself accordingly. Design pattern literature commonly refers to views as 'dumb', given that their knowledge of models and controllers in an application is limited.

Let's explore Views a little further using a simple JavaScript example:

```javascript
// DOM View
var View = Cranium.View = function (options) {
  // Mix in options object (e.g extending functionality)
  _.extend(this, options); 
  this.id = _.uniqueId('view');
};

// Mix in Event system
_.extend(Cranium.View.prototype, Cranium.Events);
```

### Controllers

Controllers are an intermediary between models and views which are classically responsible for two tasks: 

* they update the view when the model changes
* they update the model when the user manipulates the view

```javascript
// cranium.js - Cranium.Controller

// Controller tying together a model and view
var Controller = Cranium.Controller = function(options){
  // Mix in options object (e.g extending functionality)
  _.extend(this, options); 
  this.id = _.uniqueId('controller');
  var parts, selector, eventType;

  // Parses Events object passed during the definition of the 
  // controller and maps it to the defined method to handle it;
  if(this.events){
    _.each(this.events, function(method, eventName){
      parts = eventName.split('.');
      selector = parts[0];
      eventType = parts[1];
      $(selector)['on' + eventType] = this[method];
    }.bind(this));
  }    
};
```

### Practical Usage

HTML template for the primer that follows:

```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title></title>
  <meta name="description" content="">
</head>
<body>
<div id="todo">
</div>
  <script type="text/template" class="todo-template">
    <div>
      <input id="todo_complete" type="checkbox" <%= completed %>>
      <%= title %>
    </div>
  </script>
  <script src="underscore-min.js"></script>
  <script src="cranium.js"></script>
  <script src="example.js"></script>
</body>
</html>
```

Cranium.js usage:

```javascript

// example.js - usage of Cranium MVC

// And todo instance
var todo1 = new Cranium.Model({
    title: "",
    completed: ""
});

console.log("First todo title - nothing set: " + todo1.get('title'));
todo1.set({title: "Do something"});
console.log("Its changed now: " + todo1.get('title'));
''
// View instance
var todoView = new Cranium.View({
  // DOM element selector
  el: '#todo',

  // Todo template; Underscore temlating used
  template: _.template($('.todo-template').innerHTML),

  init: function (model) {
    this.render( model.toJSON() );

    this.on(model.id + 'update', this.render.bind(this));
  },
  render: function (data) {
    console.log("View about to render.");
    $(this.el).innerHTML = this.template( data );
  }
});

var todoController = new Cranium.Controller({
  // Specify the model to update
  model: todo1,

  // and the view to observe this model
  view:  todoView,
  
  events: {
    "#todo.click" : "toggleComplete"
  },

  // Initialize everything
  initialize: function () {
    this.view.init(this.model);
    return this;
  },
  // Toggles the value of the todo in the Model
  toggleComplete: function () {
    var completed = todoController.model.get('completed');
    console.log("Todo old 'completed' value?", completed);
    todoController.model.set({ completed: (!completed) ? 'checked': '' });
    console.log("Todo new 'completed' value?", todoController.model.get('completed'));
    return this;
  }
});


// Let's kick start things off
todoController.initialize();

todo1.set({ title: "Due to this change Model will notify View and it will re-render"});

```

Samuel Clay, one of the authors of the first version of Backbone.js says of cranium.js: "Unsurprisingly, it looks a whole lot like the beginnings of Backbone. Views are dumb, so they get very little boilerplate and setup. Models are responsible for their attributes and announcing changes to those models."

I hope you've found this implementation helpful in understanding how one would go about writing their own library like Backbone from scratch, but moreso that it encourages you to take advantage of mature existing solutions where possible but never be afraid to explore deeper down into what makes them tick.

## MVP

Model-View-Presenter (MVP) is a derivative of the MVC design pattern which focuses on improving presentation logic. It originated at a company named [Taligent](http://en.wikipedia.org/wiki/Taligent) in the early 1990s while they were working on a model for a C++ CommonPoint environment. Whilst both MVC and MVP target the separation of concerns across multiple components, there are some fundamental differences between them.

For the purposes of this summary we will focus on the version of MVP most suitable for web-based architectures.

### Models, Views & Presenters

The P in MVP stands for presenter. It's a component which contains the user-interface business logic for the view. Unlike MVC, invocations from the view are delegated to the presenter, which are decoupled from the view and instead talk to it through an interface. This allows for all kinds of useful things such as being able to mock views in unit tests.

The most common implementation of MVP is one which uses a Passive View (a view which is for all intents and purposes "dumb"), containing little to no logic. MVP models are almost identical to MVC models and handle application data. The presenter acts as a mediator which talks to both the view and model, however both of these are isolated from each other. They effectively bind models to views, a responsibility held by Controllers in MVC. Presenters are at the heart of the MVP pattern and as you can guess, incorporate the presentation logic behind views.

Solicited by a view, presenters perform any work to do with user requests and pass data back to them. In this respect, they retrieve data, manipulate it and determine how the data should be displayed in the view. In some implementations, the presenter also interacts with a service layer to persist data (models). Models may trigger events but it's the presenter's role to subscribe to them so that it can update the view. In this passive architecture, we have no concept of direct data binding. Views expose setters which presenters can use to set data.

The benefit of this change from MVC is that it increases the testability of your application and provides a more clean separation between the view and the model. This isn't however without its costs as the lack of data binding support in the pattern can often mean having to take care of this task separately.

Although a common implementation of a [Passive View](http://martinfowler.com/eaaDev/PassiveScreen.html) is for the view to implement an interface, there are variations on it, including the use of events which can decouple the View from the Presenter a little more. As we don't have the interface construct in JavaScript, we're using it more and more as a protocol than an explicit interface here. It's technically still an API and it's probably fair for us to refer to it as an interface from that perspective.


There is also a [Supervising Controller](http://martinfowler.com/eaaDev/SupervisingPresenter.html) variation of MVP, which is closer to the MVC and [MVVM - Model-View-ViewModel](http://en.wikipedia.org/wiki/Model_View_ViewModel) patterns as it provides data-binding from the Model directly from the View. Key-value observing (KVO) plugins (such as Derick Bailey's Backbone.ModelBinding plugin) introduce this idea of a Supervising Controller to Backbone.


## MVP or MVC?

MVP is generally used most often in enterprise-level applications where it's necessary to reuse as much presentation logic as possible. Applications with very complex views and a great deal of user interaction may find that MVC doesn't quite fit the bill here as solving this problem may mean heavily relying on multiple controllers. In MVP, all of this complex logic can be encapsulated in a presenter, which can simplify maintenance greatly.

As MVP views are defined through an interface and the interface is technically the only point of contact between the system and the view (other than a presenter), this pattern also allows developers to write presentation logic without needing to wait for designers to produce layouts and graphics for the application.

Depending on the implementation, MVP may be more easy to automatically unit test than MVC. The reason often cited for this is that the presenter can be used as a complete mock of the user-interface and so it can be unit tested independent of other components. In my experience this really depends on the languages you are implementing MVP in (there's quite a difference between opting for MVP for a JavaScript project over one for say, ASP.NET).

At the end of the day, the underlying concerns you may have with MVC will likely hold true for MVP given that the differences between them are mainly semantic. As long as you are cleanly separating concerns into models, views and controllers (or presenters) you should be achieving most of the same benefits regardless of the pattern you opt for.

## MVC, MVP and Backbone.js

There are very few, if any architectural JavaScript frameworks that claim to implement the MVC or MVP patterns in their classical form as many JavaScript developers don't view MVC and MVP as being mutually exclusive (we are actually more likely to see MVP strictly implemented when looking at web frameworks such as ASP.NET or GWT). This is because it's possible to have additional presenter/view logic in your application and yet still consider it a flavor of MVC.

Backbone contributor [Irene Ros](http://ireneros.com/) subscribes to this way of thinking as when she separates Backbone views out into their own distinct components, she needs something to actually assemble them for her. This could either be a controller route (such as a ```Backbone.Router```) or a callback in response to data being fetched.

That said, some developers do however feel that Backbone.js better fits the description of MVP than it does MVC
. Their view is that:

* The presenter in MVP better describes the ```Backbone.View``` (the layer between View templates and the data bound to it) than a controller does
* The model fits ```Backbone.Model``` (it isn't that different from the classical MVC "Model")
* The views best represent templates (e.g Handlebars/Mustache markup templates)

A response to this could be that the view can also just be a View (as per MVC) because Backbone is flexible enough to let it be used for multiple purposes. The V in MVC and the P in MVP can both be accomplished by ```Backbone.View``` because they're able to achieve two purposes: both rendering atomic components and assembling those components rendered by other views.

We've also seen that in Backbone the responsibility of a controller is shared with both the Backbone.View and Backbone.Router and in the following example we can actually see that aspects of that are certainly true.

Here, our Backbone ```TodoView``` uses the Observer pattern to 'subscribe' to changes to a View's model in the line ```this.model.on('change',...)```. It also handles templating in the ```render()``` method, but unlike some other implementations, user interaction is also handled in the View (see ```events```).


```javascript
// The DOM element for a todo item...
app.TodoView = Backbone.View.extend({

  //... is a list tag.
  tagName:  'li',

  // Pass the contents of the todo template through a templating
  // function, cache it for a single todo
  template: _.template( $('#item-template').html() ),

  // The DOM events specific to an item.
  events: {
    'click .toggle':  'togglecompleted'
  },

  // The TodoView listens for changes to its model, re-rendering. Since there's
  // a one-to-one correspondence between a **Todo** and a **TodoView** in this
  // app, we set a direct reference on the model for convenience.
  initialize: function() {
    this.model.on( 'change', this.render, this );
    this.model.on( 'destroy', this.remove, this );
  },

  // Re-render the titles of the todo item.
  render: function() {
    this.$el.html( this.template( this.model.toJSON() ) );
    return this;
  },

  // Toggle the `"completed"` state of the model.
  togglecompleted: function() {
    this.model.toggle();
  },
});
```

Another (quite different) opinion is that Backbone more closely resembles [Smalltalk-80 MVC](http://martinfowler.com/eaaDev/uiArchs.html#ModelViewController), which we went through earlier.

As MarionetteJS author Derick Bailey has [written](http://lostechies.com/derickbailey/2011/12/23/backbone-js-is-not-an-mvc-framework/), it's ultimately best not to force Backbone to fit any specific design patterns. Design patterns should be considered flexible guides to how applications may be structured and in this respect, Backbone doesn't fit either MVC nor MVP perfectly. Instead, it borrows some of the best concepts from multiple architectural patterns and creates a flexible framework that just works well. Call it **the Backbone way**, MV* or whatever helps reference its flavor of application architecture.

It *is* however worth understanding where and why these concepts originated, so I hope that my explanations of MVC and MVP have been of help. Most structural JavaScript frameworks will adopt their own take on classical patterns, either intentionally or by accident, but the important thing is that they help us develop applications which are organized, clean and can be easily maintained.

## Namespacing

When learning how to use Backbone, an important and commonly overlooked area by tutorials is namespacing. If you already have experience with namespacing in JavaScript, the following section will provide some advice on how to specifically apply concepts you know to Backbone, however I will also be covering explanations for beginners to ensure everyone is on the same page.

#### What is namespacing?

Namespacing is a way to avoid collisions with other objects or variables in the global namespace. Using namespacing reduces the potential of your code breaking because another script on the page is using the same variable names that you are. As a good 'citizen' of the global namespace, it's also imperative that you do your best to minimize the possibility of your code breaking other developer's scripts.

JavaScript doesn't really have built-in support for namespaces like other languages, however it does have closures which can be used to achieve a similar effect.

In this section we'll be taking a look shortly at some examples of how you can namespace your models, views, routers and other components. The patterns we'll be examining are:

* Single global variables
* Object Literals
* Nested namespacing

**Single global variables**

One popular pattern for namespacing in JavaScript is opting for a single global variable as your primary object of reference. A skeleton implementation of this where we return an object with functions and properties can be found below:

```javascript
var myApplication = (function(){
    function(){
      // ...
    },
    return {
      // ...
    }
})();
```

You've probably seen this technique before. A Backbone-specific example might look like this:

```javascript
var myViews = (function(){
    return {
        TodoView: Backbone.View.extend({ .. }),
        TodosView: Backbone.View.extend({ .. }),
        AboutView: Backbone.View.extend({ .. });
        //etc.
    };
})();
```

Here we can return a set of views, but the same technique could return an entire collection of models, views and routers depending on how you decide to structure your application. Although this works for certain situations, the biggest challenge with the single global variable pattern is ensuring that no one else has used the same global variable name as you have in the page.

One solution to this problem, as mentioned by Peter Michaux, is to use prefix namespacing. It's a simple concept at heart, but the idea is you select a common prefix name (in this example, `myApplication_`) and then define any methods, variables or other objects after the prefix.

```javascript
var myApplication_todoView = Backbone.View.extend({}),
    myApplication_todosView = Backbone.View.extend({});
```

This is effective from the perspective of trying to lower the chances of a particular variable existing in the global scope, but remember that a uniquely named object can have the same effect. This aside, the biggest issue with the pattern is that it can result in a large number of global objects once your application starts to grow.

For more on Peter's views about the single global variable pattern, read his [excellent post on them](http://michaux.ca/articles/javascript-namespacing).

Note: There are several other variations on the single global variable pattern out in the wild, however having reviewed quite a few, I felt the prefixing approach applied best to Backbone.

**Object Literals**

Object Literals have the advantage of not polluting the global namespace but assist in organizing code and parameters logically. They're beneficial if you wish to create easily readable structures that can be expanded to support deep nesting. Unlike simple global variables, Object Literals often also take into account tests for the existence of a variable by the same name, which helps reduce the chances of collision.

This example demonstrates two ways you can check to see if a namespace already exists before defining it. I commonly use Option 2.

```javascript
/* Doesn't check for existence of myApplication */
var myApplication = {};

/*
Does check for existence. If already defined, we use that instance.
Option 1:   if(!myApplication) myApplication = {};
Option 2:   var myApplication = myApplication || {};
We can then populate our object literal to support models, views and collections (or any data, really):
*/

var myApplication = {
    models : {},
    views : {
        pages : {}
    },
    collections : {}
};
```

One can also opt for adding properties directly to the namespace (such as your views, in the following example):

```javascript
var myTodosViews = myTodosViews || {};
myTodosViews.todoView = Backbone.View.extend({});
myTodosViews.todosView = Backbone.View.extend({});
```

The benefit of this pattern is that you're able to easily encapsulate all of your models, views, routers etc. in a way that clearly separates them and provides a solid foundation for extending your code.

This pattern has a number of benefits. It's often a good idea to decouple the default configuration for your application into a single area that can be easily modified without the need to search through your entire codebase just to alter it. Here's an example of a hypothetical object literal that stores application configuration settings:


```javascript
var myConfig = {
  language: 'english',
  defaults: {
    enableDelegation: true,
    maxTodos: 40
  },
  theme: {
    skin: 'a',
    toolbars: {
      index: 'ui-navigation-toolbar',
      pages: 'ui-custom-toolbar'
    }
  }
}
```

Note that there are really only minor syntactical differences between the Object Literal pattern and a standard JSON data set. If for any reason you wish to use JSON for storing your configurations instead (e.g. for simpler storage when sending to the back-end), feel free to.

For more on the Object Literal pattern, I recommend reading Rebecca Murphey's [excellent article on the topic](http://rmurphey.com/blog/2009/10/15/using-objects-to-organize-your-code).

**Nested namespacing**

An extension of the Object Literal pattern is nested namespacing. It's another common pattern used that offers a lower risk of collision due to the fact that even if a top-level namespace already exists, it's unlikely the same nested children do. For example, Yahoo's YUI uses the nested object namespacing pattern extensively:

```javascript
YAHOO.util.Dom.getElementsByClassName('test');
```

Yahoo's YUI uses the nested object namespacing pattern regularly and even DocumentCloud (the creators of Backbone) use the nested namespacing pattern in their main applications. A sample implementation of nested namespacing with Backbone may look like this:

```javascript
var todoApp =  todoApp || {};

// perform similar check for nested children
todoApp.routers = todoApp.routers || {};
todoApp.model = todoApp.model || {};
todoApp.model.special = todoApp.model.special || {};

// routers
todoApp.routers.Workspace   = Backbone.Router.extend({});
todoApp.routers.TodoSearch = Backbone.Router.extend({});

// models
todoApp.model.Todo   = Backbone.Model.extend({});
todoApp.model.Notes = Backbone.Model.extend({});

// special models
todoApp.model.special.Admin = Backbone.Model.extend({});
```

This is readable, clearly organized, and is a relatively safe way of namespacing your Backbone application. The only real caveat however is that it requires your browser's JavaScript engine to first locate the todoApp object, then dig down until it gets to the function you're calling. However, developers such as Juriy Zaytsev (kangax) have tested and found the performance differences between single object namespacing vs the 'nested' approach to be quite negligible.

**What does DocumentCloud use?**

In case you were wondering, here is the original DocumentCloud (remember those guys that created Backbone?) workspace that uses namespacing in a necessary way. This approach makes sense as their documents (and annotations and document lists) are embedded on third-party news sites.

```javascript

// Provide top-level namespaces for our javascript.
(function() {
  window.dc = {};
  dc.controllers = {};
  dc.model = {};
  dc.app = {};
  dc.ui = {};
})();
```

As you can see, they opt for declaring a top-level namespace on the `window` called `dc`, a short-form name of their app, followed by nested namespaces for the controllers, models, UI and other pieces of their application.

**Recommendation**

Reviewing the namespace patterns above, the option that I prefer when writing Backbone applications is nested object namespacing with the object literal pattern.

Single global variables may work fine for applications that are relatively trivial. However, larger codebases requiring both namespaces and deep sub-namespaces require a succinct solution that's both readable and scalable. I feel this pattern achieves both of these objectives and is a good choice for most Backbone development.


## Backbone Dependency Details

The following sections provide insight into how Backbone uses jQuery/Zepto and Underscore.js.

### DOM Manipulation

Although most developers won't need it, Backbone does support setting a custom DOM library to be used instead of these options. From the source:

```
// For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
// the `$` variable.
 Backbone.$ = root.jQuery || root.Zepto || root.ender || root.$;
```

So, setting `Backbone.$ = myLibrary;` will allow you to use any custom DOM-manipulation library in place of the jQuery default.

### Utilities

Underscore.js is heavily used in Backbone behind the scenes for everything from object extension to event binding. As the entire library is generally included, we get free access to a number of useful utilities we can use on Collections such as filtering `_.filter()`, sorting `_.sortBy()`, mapping `_.map()` and so on. 

From the source:

```
// Underscore methods that we want to implement on the Collection.
// 90% of the core usefulness of Backbone Collections is actually implemented
// right here:
var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl', 'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select', 'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke', 'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest', 'tail', 'drop', 'last', 'without', 'indexOf', 'shuffle', 'lastIndexOf', 'isEmpty', 'chain'];

// Mix in each Underscore method as a proxy to `Collection#models`.
_.each(methods, function(method) {
    Collection.prototype[method] = function() {
        var args = slice.call(arguments);
        args.unshift(this.models);
        return _[method].apply(_, args);
    };
});
```

However, for a complete linked list of methods supported, see the [official documentation](http://backbonejs.org/#Collection-Underscore-Methods).

### RESTful persistence

Models and collections in Backbone can be "sync"ed with the server using the `fetch`, `save` and `destroy` methods. All of these methods delegate back to the `Backbone.sync` function, which actually wraps jQuery/Zepto's `$.ajax` function, calling GET, POST and DELETE for the respective persistence methods on Backbone models. 

From the the source for `Backbone.sync`:

```
var methodMap = {
  'create': 'POST',
  'update': 'PUT',
  'patch':  'PATCH',
  'delete': 'DELETE',
  'read':   'GET'
};
  
Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // ... Followed by lots of Backbone.js configuration, then..
    
    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
```

### Routing

Calls to `Backbone.History.start` rely on jQuery/Zepto binding `popState` or `hashchange` event listeners back to the window object. 

From the source for `Backbone.history.start`:

```
      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._hasPushState) {
          Backbone.$(window)
              .on('popstate', this.checkUrl);
      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
          Backbone.$(window)
              .on('hashchange', this.checkUrl);
      } else if (this._wantsHashChange) {
          this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }
      ...
```

`Backbone.History.stop` similarly uses your DOM manipulation library to unbind these event listeners.


## Backbone Vs. Other Libraries And Frameworks

Backbone is just one of many different solutions available for structuring your application and we're by no means advocating it as the be all and end all. It's served the authors of this book well in building many simple and complex web applications and we hope that it can serve you equally as well. The answer to the question 'Is Backbone better than X?' generally has a lot more to do with what kind of application you're building.

AngularJS and Ember.js are examples of powerful alternatives but differ from Backbone in that there are more opinionated. For some projects this can be useful and for others, perhaps not. The important thing to remember is that there is no library or framework that's going to be the best solution for every use-case and so it's important to learn about the tools at your disposal and decide which one is best on a project-by-project basis. 

Choose the right tool for the right job. This is why we recommend spending some time doing a little due diligence. Consider productivity, ease of use, testability, community and documentation. If you're looking for more concrete comparisons between frameworks, read:

* [Journey Through The JavaScript MVC Jungle](http://coding.smashingmagazine.com/2012/07/27/journey-through-the-javascript-mvc-jungle/)
* [Throne of JS - Seven JavaScript Frameworks](http://blog.stevensanderson.com/2012/08/01/rich-javascript-applications-the-seven-frameworks-throne-of-js-2012/)

The authors behind Backbone.js, AngularJS and Ember have also discussed some of the strengths and weaknesses of their solutions on Quora, StackOverflow and so on:

* [Jeremy Ashkenas on Why Backbone?](http://backbonejs.org/#FAQ-why-backbone)
* [Tom Dale on Why Ember.js vs. AngularJS](http://www.quora.com/Ember-js/Which-one-of-angular-js-and-ember-js-is-the-better-choice/answer/Tom-Dale)
* [Brian Ford & Jeremy Ashkenas on Backbone vs. Angular (discussion)](http://www.reddit.com/r/javascript/comments/17h22w/an_introduction_to_angular_for_backbone_developers/) 

The solution you opt for may need to support building non-trivial features and could end up being used to maintain the app for years to come so think about things like:

**What is the library/framework really capable of?**

Spend time reviewing both the source code of the framework and official list of features to see how well they fit with your requirements. There will be projects that may require modifying or extending the underlying source and thus make sure that if this might be the case, you’ve performed due diligence on the code.
Has the framework been proven in production?

i.e Have developers actually built and deployed large applications with it that are publicly accessible? Backbone has a strong portfolio of these (SoundCloud, LinkedIn, Walmart) but not all frameworks do. Ember is used in number of large apps, including the new version of ZenDesk. AngularJS has been used to build the YouTube app for PS3 amongst other places. It’s not only important to know that a framework works in production, but also being able to look at real world code and be inspired by what can be built with it.

**Is the framework mature?**

I generally recommend developers don’t simply “pick one and go with it”. New projects often come with a lot of buzz surrounding their releases but remember to take care when selecting them for use on a production-level app. You don’t want to risk the project being canned, going through major periods of refactoring or other breaking changes that tend to be more carefully planned out when a framework is mature. Mature projects also tend to have more detailed documentation available, either as a part of their official or community-driven docs.

**Is the framework flexible or opinionated?**

Know what flavor you’re after as there are plenty of frameworks available which provide one or the other. Opinionated frameworks lock (or suggest) you to do things in a specific way (theirs). By design they are limiting, but place less emphasis on the developer having to figure out how things should work on their own.
Have you really played with the framework?

Write a small application without using frameworks and then attempt to refactor your code with a framework to confirm whether it’s easy to work with or not. As much as researching and reading up on code will influence your decision, it’s equally as important to write actual code using the framework to make sure you’re comfortable with the concepts it enforces.

**Does the framework have a comprehensive set of documentation?**

Although demo applications can be useful for reference, you’ll almost always find yourself consulting the official framework docs to find out what its API supports, how common tasks or components can be created with it and what the gotchas worth noting are. Any framework worth it’s salt should have a detailed set of documentation which will help guide developers using it. Without this, you can find yourself heavily relying on IRC channels, groups and self-discovery, which can be fine, but are often overly time-consuming when compared to a great set of docs provided upfront.

**What is the total size of the framework, factoring in minification, gzipping and any modular building that it supports?**

What dependencies does the framework have? Frameworks tend to only list the total filesize of the base library itself, but don’t list the sizes of the library's dependencies. This can mean the difference between opting for a library that initially looks quite small, but could be relatively large if it say, depends on jQuery and other libraries.

**Have you reviewed the community around the framework?**

Is there an active community of project contributors and users who would be able to assist if you run into issues? Have enough developers been using the framework that there are existing reference applications, tutorials and maybe even screencasts that you can use to learn more about it?


---
Where relevant, copyright Addy Osmani, 2012-2013.
